<!DOCTYPE html>
<!-- saved from url=(0055)#_label16 -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
<titl./source</title>
<meta property="og:description" content="===============第一部分 Python基础篇（80题）=============== 1. 为什么学习Python？ 2. 通过什么途径学习的Python？ 3. Python和Java">
<link type="text/css" rel="stylesheet" href="./source_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./source_files/bundle-LessIsMore.css">
<link type="text/css" rel="stylesheet" href="./source_files/388477.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./source_files/bundle-LessIsMore-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/iyouyue/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/iyouyue/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/iyouyue/wlwmanifest.xml">
<script src="./source_files/f.txt"></script><script src="./source_files/pubads_impl_rendering_285.js"></script><script async="" src="./source_files/analytics.js"></script><script src="./source_files/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'iyouyue', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./source_files/blog-common.js" type="text/javascript"></script>
<link rel="preload" href="./source_files/f(1).txt" as="script"><script type="text/javascript" src="./source_files/f(1).txt"></script><script src="./source_files/pubads_impl_285.js" async=""></script><link rel="stylesheet" href="./source_files/font-awesome.css"><link rel="prefetch" href="https://tpc.googlesyndication.com/safeframe/1-0-31/html/container.html"></head>
<body><div class="fa fa-search-minus fa-2" id="zoomoutbutton" style="width: 24px; height: 24px; right: 32px; bottom: 96px; z-index: 999999; cursor: pointer; position: fixed; margin: 0px auto; color: rgb(5, 147, 211); font-size: 24px; display: none;"></div><div class="fa fa-search-plus fa-2" id="zoominbutton" style="width: 24px; height: 24px; right: 32px; bottom: 128px; z-index: 999999; cursor: pointer; position: fixed; margin: 0px auto; color: rgb(5, 147, 211); font-size: 24px; display: none;"></div><div class="fa fa-print fa-2" id="printbutton" style="width: 24px; height: 24px; right: 32px; bottom: 64px; z-index: 999999; cursor: pointer; position: fixed; margin: 0px auto; color: rgb(5, 147, 211); font-size: 24px; display: none;"></div><div class="fa fa-book fa-2" id="readbutton" style="width: 24px; height: 24px; right: 32px; bottom: 32px; z-index: 999999; cursor: pointer; position: fixed; margin: 0px auto; color: rgb(5, 147, 211); font-size: 24px;"></div>
<a name="top"></a>

<div id="home">
<div id="header">
	<div id="blogTitle">

<!--done-->





	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">

<ul id="navList">
<li id="nav_sitehome"></li>

</ul>

		<div class="blogStats">



		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">

<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href=""></a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"><a name="_labelTop"></a><div id="navCategory" style="color:#152e97;"><p style="font-size:18px;"><b>阅读目录</b></p><ul><li><a href="#_label0">===============第一部分 Python基础篇（80题）===============</a></li><li><a href="#_label1">1. 为什么学习Python？</a></li><li><a href="#_label2">2. 通过什么途径学习的Python？</a></li><li><a href="#_label3">3. Python和Java、PHP、C、C#、C++等其他语言的对比？</a></li><li><a href="#_label4">4. 简述解释型和编译型编程语言？</a></li><li><a href="#_label5">5. Python解释器种类以及特点？</a></li><li><a href="#_label6">6. 位和字节的关系？</a></li><li><a href="#_label7">7. b、B、KB、MB、GB 的关系？</a></li><li><a href="#_label8">8. 请至少列举5个 PEP8 规范（越多越好）。</a></li><li><a href="#_label9">9. 通过代码实现进制转换</a></li><li><a href="#_label10">10. 请编写一个函数实现将IP地址转换成一个整数。</a></li><li><a href="#_label11">11. python递归的最大层数？</a></li><li><a href="#_label12">12. 求逻辑运算符的结果</a></li><li><a href="#_label13">13. ascii、unicode、utf-8、gbk 区别？</a></li><li><a href="#_label14">14. 字节码和机器码的区别？</a></li><li><a href="#_label15">15. 三元运算规则以及应用场景？</a></li><li><a href="#_label16">16. 列举 Python2和Python3的区别？</a></li><li><a href="#_label17">17. 用一行代码实现数值交换</a></li><li><a href="#_label18">18. Python3和Python2中 int 和 long的区别？</a></li><li><a href="#_label19">19. xrange和range的区别？</a></li><li><a href="#_label20">20. 文件操作时：xreadlines和readlines的区别？</a></li><li><a href="#_label21">21. 列举布尔值为False的常见值？</a></li><li><a href="#_label22">22. 字符串、列表、元组、字典每个常用的5个方法？</a></li><li><a href="#_label23">23. lambda表达式格式以及应用场景？</a></li><li><a href="#_label24">24. pass的作用？</a></li><li><a href="#_label25">25. arg和kwarg作用</a></li><li><a href="#_label26">26. is和==的区别</a></li><li><a href="#_label27">27. 简述Python的深浅拷贝以及应用场景？</a></li><li><a href="#_label28">28. Python垃圾回收机制？</a></li><li><a href="#_label29">29. Python的可变类型和不可变类型？</a></li><li><a href="#_label30">30. 求可变数据类型结果</a></li><li><a href="#_label31">31. 求匿名函数结果</a></li><li><a href="#_label32">32. 列举常见的内置函数？</a></li><li><a href="#_label33">33. filter、map、reduce的作用？</a></li><li><a href="#_label34">34. 一行代码实现9乘9乘法表</a></li><li><a href="#_label35">35. 如何安装第三方模块？以及用过哪些第三方模块？</a></li><li><a href="#_label36">36. 常用模块都有哪些？</a></li><li><a href="#_label37">37. re的match和search区别？</a></li><li><a href="#_label38">38. 什么是正则的贪婪匹配？</a></li><li><a href="#_label39">39. 求结果：a. [ i % 2 for i in range(10) ] b. ( i % 2 for i in range(10) )</a></li><li><a href="#_label40">40. 求结果：a. 1 or 2 b. 1 and 2 c. 1 &lt; (2==2) d. 1 &lt; 2 == 2</a></li><li><a href="#_label41">41. def func(a,b=[]) 这种写法有什么坑？</a></li><li><a href="#_label42">42. 如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</a></li><li><a href="#_label43">43. 如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</a></li><li><a href="#_label44">44. 比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 b = [(1,),(2,),(3,) ] 的区别？</a></li><li><a href="#_label45">45. 如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</a></li><li><a href="#_label46">46. 一行代码实现删除列表中重复的值 ?</a></li><li><a href="#_label47">47. 如何在函数中设置一个全局变量 ?</a></li><li><a href="#_label48">48. logging模块的作用？以及应用场景？</a></li><li><a href="#_label49">49. 请用代码简单实现一个栈。</a></li><li><a href="#_label50">50. 常用字符串格式化哪几种？</a></li><li><a href="#_label51">51. 简述 生成器、迭代器、可迭代对象 以及应用场景？</a></li><li><a href="#_label52">52. 用Python实现一个二分查找的函数。</a></li><li><a href="#_label53">53. 谈谈你对闭包的理解？</a></li><li><a href="#_label54">54. os和sys模块的作用？</a></li><li><a href="#_label55">55. 如何生成一个随机数？</a></li><li><a href="#_label56">56. 如何使用python删除一个文件？</a></li><li><a href="#_label57">57. 谈谈你对面向对象的理解？</a></li><li><a href="#_label58">58. Python面向对象中的继承有什么特点？</a></li><li><a href="#_label59">59. 面向对象深度优先和广度优先是什么？</a></li><li><a href="#_label60">60. 面向对象中super的作用？</a></li><li><a href="#_label61">61. 是否使用过functools中的函数？其作用是什么？</a></li><li><a href="#_label62">62. 列举面向对象中带双下划线的特殊方法，如：new、init</a></li><li><a href="#_label63">63. 如何判断是函数还是方法？</a></li><li><a href="#_label64">64. 静态方法和类方法区别？</a></li><li><a href="#_label65">65. 列举面向对象中的特殊成员以及应用场景</a></li><li><a href="#_label66">66. 1、2、3、4、5 能组成多少个互不相同且无重复的三位数</a></li><li><a href="#_label67">67. 什么是反射？以及应用场景？</a></li><li><a href="#_label68">68. metaclass作用？以及应用场景？</a></li><li><a href="#_label69">69. 用尽量多的方法实现单例模式。</a></li><li><a href="#_label70">70. 装饰器的写法以及应用场景。</a></li><li><a href="#_label71">71. 异常处理写法以及如何主动跑出异常（应用场景）</a></li><li><a href="#_label72">72. 什么是面向对象的mro</a></li><li><a href="#_label73">73. isinstance作用以及应用场景？</a></li><li><a href="#_label74">74. 写代码并实现LeetCode两数之和：</a></li><li><a href="#_label75">75. json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</a></li><li><a href="#_label76">76. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？</a></li><li><a href="#_label77">77. 什么是断言？应用场景？</a></li><li><a href="#_label78">78. 有用过with statement吗？它的好处是什么？</a></li><li><a href="#_label79">79. 使用代码实现查看列举目录下的所有文件。</a></li><li><a href="#_label80">80. 简述 yield和yield from关键字。</a></li><li><a href="#_label81">===============第二部分 网络编程和并发（34题）===============</a></li><li><a href="#_label82">1. 简述 OSI 七层协议。</a></li><li><a href="#_label83">2. 什么是C/S和B/S架构？</a></li><li><a href="#_label84">3. 简述 三次握手、四次挥手的流程。</a></li><li><a href="#_label85">4. 什么是arp协议？</a></li><li><a href="#_label86">5. TCP和UDP的区别？</a></li><li><a href="#_label87">6. 什么是局域网和广域网？</a></li><li><a href="#_label88">7. 为何基于tcp协议的通信比基于udp协议的通信更可靠？</a></li><li><a href="#_label89">8. 什么是socket？简述基于tcp协议的套接字通信流程。</a></li><li><a href="#_label90">9. 什么是粘包？ socket 中造成粘包的原因是什么？</a></li><li><a href="#_label91">10. IO多路复用的作用？</a></li><li><a href="#_label92">11. 什么是防火墙以及作用？</a></li><li><a href="#_label93">12. select、poll、epoll 模型的区别？</a></li><li><a href="#_label94">13. 简述 进程、线程、协程的区别 以及应用场景？</a></li><li><a href="#_label95">14. GIL锁是什么鬼？</a></li><li><a href="#_label96">15. Python中如何使用线程池和进程池？</a></li><li><a href="#_label97">16. threading.local的作用？</a></li><li><a href="#_label98">17. 进程之间如何进行通信？</a></li><li><a href="#_label99">18. 什么是并发和并行？</a></li><li><a href="#_label100">19. 进程锁和线程锁的作用？</a></li><li><a href="#_label101">20. 解释什么是异步非阻塞？</a></li><li><a href="#_label102">21. 路由器和交换机的区别？</a></li><li><a href="#_label103">22. 什么是域名解析？</a></li><li><a href="#_label104">23. 如何修改本地hosts文件？</a></li><li><a href="#_label105">24. 生产者消费者模型应用场景及优势？</a></li><li><a href="#_label106">25. 什么是CDN？</a></li><li><a href="#_label107">26. LVS是什么及作用？</a></li><li><a href="#_label108">27. Nginx是什么及作用？</a></li><li><a href="#_label109">28. keepalived是什么及作用?</a></li><li><a href="#_label110">29. haproxy是什么以及作用？</a></li><li><a href="#_label111">30. 什么是负载均衡？</a></li><li><a href="#_label112">31.什么是RPC及应用场景？</a></li><li><a href="#_label113">32.简述 asynio模块的作用和应用场景。</a></li><li><a href="#_label114">33.简述 gevent模块的作用和应用场景。</a></li><li><a href="#_label115">34.twisted框架的使用和应用？</a></li><li><a href="#_label116">===============第三部分 数据库和缓存（46题）===============</a></li><li><a href="#_label117">1. 列举常见的关系型数据库和非关系型都有哪些？</a></li><li><a href="#_label118">2. MySQL常见数据库引擎及比较？</a></li><li><a href="#_label119">3. 简述数据三大范式？</a></li><li><a href="#_label120">4. 什么是事务？MySQL如何支持事务？</a></li><li><a href="#_label121">5. 简述数据库设计中一对多和多对多的应用场景？</a></li><li><a href="#_label122">6. 如何基于数据库实现商城商品计数器？</a></li><li><a href="#_label123">7. 常见SQL（必备）</a></li><li><a href="#_label124">8. 简述触发器、函数、视图、存储过程？</a></li><li><a href="#_label125">9. MySQL索引种类</a></li><li><a href="#_label126">10. 索引在什么情况下遵循最左前缀的规则？</a></li><li><a href="#_label127">11. 主键和外键的区别？</a></li><li><a href="#_label128">12. MySQL常见的函数？</a></li><li><a href="#_label129">13. 列举 创建索引但是无法命中索引的8种情况。</a></li><li><a href="#_label130">14. 如何开启慢日志查询？</a></li><li><a href="#_label131">15. 数据库导入导出命令（结构+数据）？</a></li><li><a href="#_label132">16. 数据库优化方案？</a></li><li><a href="#_label133">17. char和varchar的区别？</a></li><li><a href="#_label134">18. 简述MySQL的执行计划？</a></li><li><a href="#_label135">19. 在对name做了唯一索引前提下，简述limit 1 作用</a></li><li><a href="#_label136">20. 1000w条数据，使用limit offset 分页时，为什么越往后翻越慢？如何解决？</a></li><li><a href="#_label137">21. 什么是索引合并？</a></li><li><a href="#_label138">22. 什么是覆盖索引？</a></li><li><a href="#_label139">23. 简述数据库读写分离？</a></li><li><a href="#_label140">24. 简述数据库分库分表？（水平、垂直）</a></li><li><a href="#_label141">25. redis和memcached比较？</a></li><li><a href="#_label142">26. redis中数据库默认是多少个db 及作用？</a></li><li><a href="#_label143">27. python操作redis的模块？</a></li><li><a href="#_label144">28. 如果redis中的某个列表中的数据量非常大，如果实现循环显示每一个值？</a></li><li><a href="#_label145">29. redis如何实现主从复制？以及数据同步机制？</a></li><li><a href="#_label146">30. redis中的sentinel的作用？</a></li><li><a href="#_label147">31. 如何实现redis集群？</a></li><li><a href="#_label148">32. redis中默认有多少个哈希槽？</a></li><li><a href="#_label149">33. 简述redis的有哪几种持久化策略及比较？</a></li><li><a href="#_label150">34. 列举redis支持的过期策略(数据淘汰策略)。</a></li><li><a href="#_label151">35. MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中都是热点数据？</a></li><li><a href="#_label152">36. 写代码，基于redis的列表实现 先进先出、后进先出队列、优先级队列。</a></li><li><a href="#_label153">37. 如何基于redis实现消息队列？</a></li><li><a href="#_label154">38. 如何基于redis实现发布和订阅？以及发布订阅和消息队列的区别？</a></li><li><a href="#_label155">39. 什么是codis及作用？</a></li><li><a href="#_label156">40. 什么是twemproxy及作用？</a></li><li><a href="#_label157">41. 写代码实现redis事务操作。</a></li><li><a href="#_label158">42. redis中的watch的命令的作用？</a></li><li><a href="#_label159">43. 基于redis如何实现商城商品数量计数器？</a></li><li><a href="#_label160">44. 简述redis分布式锁和redlock的实现机制。</a></li><li><a href="#_label161">45. 什么是一致性哈希？Python中是否有相应模块？</a></li><li><a href="#_label162">46. 如何高效的找到redis中所有以aaa开头的key？</a></li><li><a href="#_label163">==============第四部分 前端、框架和其他（155题）===============</a></li><li><a href="#_label164">1. 谈谈你对http协议的认识。</a></li><li><a href="#_label165">2. 谈谈你对websocket协议的认识。</a></li><li><a href="#_label166">3. 什么是magic string ？</a></li><li><a href="#_label167">4. 如何创建响应式布局？</a></li><li><a href="#_label168">5. 你曾经使用过哪些前端框架？</a></li><li><a href="#_label169">6. 什么是ajax请求？并使用jQuery和XMLHttpRequest对象实现一个ajax请求。</a></li><li><a href="#_label170">7. 如何在前端实现轮询？</a></li><li><a href="#_label171">8. 如何在前端实现长轮询？</a></li><li><a href="#_label172">9. vuex的作用？</a></li><li><a href="#_label173">10. Vue中的路由的拦截器的作用？</a></li><li><a href="#_label174">11. axios的作用？</a></li><li><a href="#_label175">12. 列举Vue的常见指令。</a></li><li><a href="#_label176">13. 简述JSONP及实现原理？</a></li><li><a href="#_label177">14. 是什么CORS ？</a></li><li><a href="#_label178">15. 列举Http请求中常见的请求方式？</a></li><li><a href="#_label179">16. 列举Http请求中的状态码？</a></li><li><a href="#_label180">17. 列举Http请求中常见的请求头？</a></li><li><a href="#_label181">18. 看图写结果：JS，略</a></li><li><a href="#_label182">19. 看图写结果：JS，略</a></li><li><a href="#_label183">20. 看图写结果：JS，略</a></li><li><a href="#_label184">21. 看图写结果：JS，略</a></li><li><a href="#_label185">22. 看图写结果：JS，略</a></li><li><a href="#_label186">23. 看图写结果：JS，略</a></li><li><a href="#_label187">24. django、flask、tornado框架的比较？</a></li><li><a href="#_label188">25. 什么是wsgi？</a></li><li><a href="#_label189">26. django请求的生命周期？</a></li><li><a href="#_label190">27. 列举django的内置组件？</a></li><li><a href="#_label191">28. 列举django中间件的5个方法？以及django中间件的应用场景？</a></li><li><a href="#_label192">29. 简述什么是FBV和CBV？</a></li><li><a href="#_label193">30. django的request对象是在什么时候创建的？</a></li><li><a href="#_label194">31. 如何给CBV的程序添加装饰器？</a></li><li><a href="#_label195">32. 列举django orm 中所有的方法（QuerySet对象的所有方法）</a></li><li><a href="#_label196">33. only和defer的区别？</a></li><li><a href="#_label197">34. select_related和prefetch_related的区别？</a></li><li><a href="#_label198">35. filter和exclude的区别？</a></li><li><a href="#_label199">36. 列举django orm中三种能写sql语句的方法。</a></li><li><a href="#_label200">37. django orm 中如何设置读写分离？</a></li><li><a href="#_label201">38. F和Q的作用?</a></li><li><a href="#_label202">39. values和values_list的区别？</a></li><li><a href="#_label203">40. 如何使用django orm批量创建数据？</a></li><li><a href="#_label204">41. django的Form和ModeForm的作用？</a></li><li><a href="#_label205">42. django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新。</a></li><li><a href="#_label206">43. django的Model中的ForeignKey字段中的on_delete参数有什么作用？</a></li><li><a href="#_label207">44. django中csrf的实现机制？</a></li><li><a href="#_label208">45. django如何实现websocket？</a></li><li><a href="#_label209">46. 基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？</a></li><li><a href="#_label210">47. django中如何实现orm表中添加数据时创建一条日志记录。</a></li><li><a href="#_label211">48. django缓存如何设置？</a></li><li><a href="#_label212">49. django的缓存能使用redis吗？如果可以的话，如何配置？</a></li><li><a href="#_label213">50. django路由系统中name的作用？</a></li><li><a href="#_label214">51. django的模板中filter和simple_tag的区别？</a></li><li><a href="#_label215">52. django-debug-toolbar的作用？</a></li><li><a href="#_label216">53. django中如何实现单元测试？</a></li><li><a href="#_label217">54. 解释orm中 db first 和 code first的含义？</a></li><li><a href="#_label218">55. django中如何根据数据库表生成model中的类？</a></li><li><a href="#_label219">56. 使用orm和原生sql的优缺点？</a></li><li><a href="#_label220">57. 简述MVC和MTV</a></li><li><a href="#_label221">58. django的contenttype组件的作用？</a></li><li><a href="#_label222">59. 谈谈你对restfull 规范的认识？</a></li><li><a href="#_label223">60. 接口的幂等性是什么意思？</a></li><li><a href="#_label224">61. 什么是RPC？</a></li><li><a href="#_label225">62. Http和Https的区别？</a></li><li><a href="#_label226">63. 为什么要使用django rest framework框架？</a></li><li><a href="#_label227">64. django rest framework框架中都有那些组件？</a></li><li><a href="#_label228">65. django rest framework框架中的视图都可以继承哪些类？</a></li><li><a href="#_label229">66. 简述 django rest framework框架的认证流程。</a></li><li><a href="#_label230">67. django rest framework如何实现的用户访问频率控制？</a></li><li><a href="#_label231">68. Flask框架的优势？</a></li><li><a href="#_label232">69. Flask框架依赖组件？</a></li><li><a href="#_label233">70. Flask蓝图的作用？</a></li><li><a href="#_label234">71. 列举使用过的Flask第三方组件？</a></li><li><a href="#_label235">72. 简述Flask上下文管理流程?</a></li><li><a href="#_label236">73. Flask中的g的作用？</a></li><li><a href="#_label237">74. Flask中上下文管理主要涉及到了那些相关的类？并描述类主要作用？</a></li><li><a href="#_label238">75. 为什么要Flask把Local对象中的的值stack 维护成一个列表？</a></li><li><a href="#_label239">76. Flask中多app应用是怎么完成？</a></li><li><a href="#_label240">77. 在Flask中实现WebSocket需要什么组件？</a></li><li><a href="#_label241">78. wtforms组件的作用？</a></li><li><a href="#_label242">79. Flask框架默认session处理机制？</a></li><li><a href="#_label243">80. 解释Flask框架中的Local对象和threading.local对象的区别？</a></li><li><a href="#_label244">81. Flask中 blinker 是什么？</a></li><li><a href="#_label245">82. SQLAlchemy中的 session和scoped_session 的区别？</a></li><li><a href="#_label246">83. SQLAlchemy如何执行原生SQL？</a></li><li><a href="#_label247">84. ORM的实现原理？</a></li><li><a href="#_label248">85. DBUtils模块的作用？</a></li><li><a href="#_label249">86. 以下SQLAlchemy的字段是否正确？如果不正确请更正：</a></li><li><a href="#_label250">87. SQLAlchemy中如何为表设置引擎和字符编码？</a></li><li><a href="#_label251">88. SQLAlchemy中如何设置联合唯一索引？</a></li><li><a href="#_label252">89. 简述Tornado框架的特点。</a></li><li><a href="#_label253">90. 简述Tornado框架中Future对象的作用？</a></li><li><a href="#_label254">91. Tornado框架中如何编写WebSocket程序？</a></li><li><a href="#_label255">92. Tornado中静态文件是如何处理的？</a></li><li><a href="#_label256">93. Tornado操作MySQL使用的模块？</a></li><li><a href="#_label257">94. Tornado操作redis使用的模块？</a></li><li><a href="#_label258">95. 简述Tornado框架的适用场景？</a></li><li><a href="#_label259">96. git常见命令作用</a></li><li><a href="#_label260">97. 简述以下git中stash命令作用以及相关其他命令。</a></li><li><a href="#_label261">98. git 中 merge 和 rebase命令 的区别。</a></li><li><a href="#_label262">99. 公司如何基于git做的协同开发？</a></li><li><a href="#_label263">100. 如何基于git实现代码review？</a></li><li><a href="#_label264">101. git如何实现v1.0 、v2.0 等版本的管理？</a></li><li><a href="#_label265">102. 什么是gitlab？</a></li><li><a href="#_label266">103. github和gitlab的区别？</a></li><li><a href="#_label267">104. 如何为github上的开源项目贡献代码？</a></li><li><a href="#_label268">105. git中 .gitignore文件的作用?</a></li><li><a href="#_label269">106. 什么是敏捷开发？</a></li><li><a href="#_label270">107. 简述 jenkins 工具的作用?</a></li><li><a href="#_label271">108. 公司如何实现代码发布？</a></li><li><a href="#_label272">109. 简述 RabbitMQ、Kafka、ZeroMQ的区别？</a></li><li><a href="#_label273">110. RabbitMQ如何在消费者获取任务后未处理完前就挂掉时，保证数据不丢失？</a></li><li><a href="#_label274">111. RabbitMQ如何对消息做持久化？</a></li><li><a href="#_label275">112. RabbitMQ如何控制消息被消费的顺序？</a></li><li><a href="#_label276">113. 以下RabbitMQ的exchange type分别代表什么意思？如：fanout、direct、topic。</a></li><li><a href="#_label277">114. 简述 celery 是什么以及应用场景？</a></li><li><a href="#_label278">115. 简述celery运行机制。</a></li><li><a href="#_label279">116. celery如何实现定时任务？</a></li><li><a href="#_label280">117. 简述 celery多任务结构目录？</a></li><li><a href="#_label281">118. celery中装饰器 @app.task 和 @shared_task的区别？</a></li><li><a href="#_label282">119. 简述 requests模块的作用及基本使用？</a></li><li><a href="#_label283">120. 简述 beautifulsoup模块的作用及基本使用？</a></li><li><a href="#_label284">121. 简述 seleninu模块的作用及基本使用?</a></li><li><a href="#_label285">122. scrapy框架中各组件的工作流程？</a></li><li><a href="#_label286">123. scrapy框架中如何设置代理（两种方法）？</a></li><li><a href="#_label287">124. scrapy框架中如何实现大文件的下载？</a></li><li><a href="#_label288">125. scrapy中如何实现限速？</a></li><li><a href="#_label289">126. scrapy中如何实现暂定爬虫？</a></li><li><a href="#_label290">127. scrapy中如何进行自定制命令？</a></li><li><a href="#_label291">128. scrapy中如何实现的记录爬虫的深度？</a></li><li><a href="#_label292">129. scrapy中的pipelines工作原理？</a></li><li><a href="#_label293">130. scrapy的pipelines如何丢弃一个item对象？</a></li><li><a href="#_label294">131. scrapy中爬虫中间件和下载中间件的作用？</a></li><li><a href="#_label295">132. scrapy-redis组件的作用？</a></li><li><a href="#_label296">133. scrapy-redis组件中如何实现的任务的去重？</a></li><li><a href="#_label297">134. scrapy-redis的调度器如何实现任务的深度优先和广度优先？</a></li><li><a href="#_label298">135. 简述 vitualenv 及应用场景?</a></li><li><a href="#_label299">136. 简述 pipreqs 及应用场景？</a></li><li><a href="#_label300">137. 在Python中使用过什么代码检查工具？</a></li><li><a href="#_label301">138. 简述 saltstack、ansible、fabric、puppet工具的作用？</a></li><li><a href="#_label302">139. B Tree和B+ Tree的区别？</a></li><li><a href="#_label303">140. 请列举常见排序并通过代码实现任意三种。</a></li><li><a href="#_label304">141. 请列举常见查找并通过代码实现任意三种。</a></li><li><a href="#_label305">142. 请列举你熟悉的设计模式？</a></li><li><a href="#_label306">143. 有没有刷过leetcode？</a></li><li><a href="#_label307">144. 列举熟悉的的Linux命令。</a></li><li><a href="#_label308">145. 公司线上服务器是什么系统？</a></li><li><a href="#_label309">146. 解释 PV、UV 的含义？</a></li><li><a href="#_label310">147. 解释 QPS的含义？</a></li><li><a href="#_label311">148. uwsgi和wsgi的区别？</a></li><li><a href="#_label312">149. supervisor的作用？</a></li><li><a href="#_label313">150. 什么是反向代理？</a></li><li><a href="#_label314">151. 简述SSH的整个过程。</a></li><li><a href="#_label315">152. 有问题都去哪找解决方案？</a></li><li><a href="#_label316">153. 是否有关注什么技术类的公众号？</a></li><li><a href="#_label317">154. 最近在研究什么新技术？</a></li><li><a href="#_label318">155. 是否了解过领域驱动模型？</a></li></ul></div><p>&nbsp;</p><hr style="height:1px;border:none;border-top:1px dashed #0066CC;"><div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label0"></a></div><h2 id="第一部分-python基础篇80题">===============第一部分 Python基础篇（80题）===============</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label1"></a></div><h2 id="为什么学习python">1. 为什么学习Python？</h2>
<pre><code class="hljs">
  是爱吗？是责任吗？都不是，是TMD穷！</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label2"></a></div><h2 id="通过什么途径学习的python">2. 通过什么途径学习的Python？</h2>
<pre><code class="hljs">
  大街上有人看我骨骼精奇，是万中无一的编程奇才，卖我本《21天精通Python》，然后……</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label3"></a></div><h2 id="python和javaphpccc等其他语言的对比">3. Python和Java、PHP、C、C#、C++等其他语言的对比？</h2>
<pre><code class="hljs">
  PHP是世界上最好的语言，Python多少差点意思</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label4"></a></div><h2 id="简述解释型和编译型编程语言">4. 简述解释型和编译型编程语言？</h2>
<pre><code class="hljs">    编译型：运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件。

    解释型：在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。最典型的代表语言为JavaScript、Python、Ruby和Perl等。 </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label5"></a></div><h2 id="python解释器种类以及特点">5. Python解释器种类以及特点？</h2>
<pre><code class="hljs css">  <span class="hljs-selector-tag">CPython</span>

  当 从<span class="hljs-selector-tag">Python</span>官方网站下载并安装好<span class="hljs-selector-tag">Python2</span><span class="hljs-selector-class">.7</span>后，就直接获得了一个官方版本的解释器：<span class="hljs-selector-tag">Cpython</span>，这个解释器是用<span class="hljs-selector-tag">C</span>语言开发的，所以叫 <span class="hljs-selector-tag">CPython</span>，在命名行下运行<span class="hljs-selector-tag">python</span>，就是启动<span class="hljs-selector-tag">CPython</span>解释器，<span class="hljs-selector-tag">CPython</span>是使用最广的<span class="hljs-selector-tag">Python</span>解释器。

  <span class="hljs-selector-tag">IPython</span>

  <span class="hljs-selector-tag">IPython</span>是基于<span class="hljs-selector-tag">CPython</span>之上的一个交互式解释器，也就是说，<span class="hljs-selector-tag">IPython</span>只是在交互方式上有所增强，但是执行<span class="hljs-selector-tag">Python</span>代码的功能和<span class="hljs-selector-tag">CPython</span>是完全一样的，好比很多国产浏览器虽然外观不同，但内核其实是调用了<span class="hljs-selector-tag">IE</span>。

  <span class="hljs-selector-tag">PyPy</span>

  <span class="hljs-selector-tag">PyPy</span>是另一个<span class="hljs-selector-tag">Python</span>解释器，它的目标是执行速度，<span class="hljs-selector-tag">PyPy</span>采用<span class="hljs-selector-tag">JIT</span>技术，对<span class="hljs-selector-tag">Python</span>代码进行动态编译，所以可以显著提高<span class="hljs-selector-tag">Python</span>代码的执行速度。

  <span class="hljs-selector-tag">Jython</span>

  <span class="hljs-selector-tag">Jython</span>是运行在<span class="hljs-selector-tag">Java</span>平台上的<span class="hljs-selector-tag">Python</span>解释器，可以直接把<span class="hljs-selector-tag">Python</span>代码编译成<span class="hljs-selector-tag">Java</span>字节码执行。

  <span class="hljs-selector-tag">IronPython</span>

  <span class="hljs-selector-tag">IronPython</span>和<span class="hljs-selector-tag">Jython</span>类似，只不过<span class="hljs-selector-tag">IronPython</span>是运行在微软<span class="hljs-selector-class">.Net</span>平台上的<span class="hljs-selector-tag">Python</span>解释器，可以直接把<span class="hljs-selector-tag">Python</span>代码编译成<span class="hljs-selector-class">.Net</span>的字节码。

  在<span class="hljs-selector-tag">Python</span>的解释器中，使用广泛的是<span class="hljs-selector-tag">CPython</span>，对于<span class="hljs-selector-tag">Python</span>的编译，除了可以采用以上解释器进行编译外，技术高超的开发者还可以按照自己的需求自行编写<span class="hljs-selector-tag">Python</span>解释器来执行<span class="hljs-selector-tag">Python</span>代码，十分的方便！</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label6"></a></div><h2 id="位和字节的关系">6. 位和字节的关系？</h2>
<pre><code class="hljs verilog">  <span class="hljs-number">1</span>.位(<span class="hljs-keyword">bit</span>)
  来自英文<span class="hljs-keyword">bit</span>，表示二进制位。位是计算机内部数据储存的最小单位，<span class="hljs-number">11010100</span>是一个<span class="hljs-number">8</span>位二进制数。一个二进制位只可以表示<span class="hljs-number">0</span>和<span class="hljs-number">1</span>两种状态；两个二进制位可以表示<span class="hljs-number">00</span>、<span class="hljs-number">01</span>、<span class="hljs-number">10</span>、<span class="hljs-number">11</span>四种状态；三位二进制数可表示八种状态。

  <span class="hljs-number">2</span>.字节(<span class="hljs-keyword">byte</span>)  
  字节来自英文Byte，习惯上用大写的“B”表示。  
  字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成，即<span class="hljs-number">1</span>个字节等于<span class="hljs-number">8</span>个比特（<span class="hljs-number">1</span>Byte=<span class="hljs-number">8</span><span class="hljs-keyword">bit</span>）。八位二进制数最小为<span class="hljs-number">00000000</span>，最大为<span class="hljs-number">11111111</span>；通常<span class="hljs-number">1</span>个字节可以存入一个ASCII码，<span class="hljs-number">2</span>个字节可以存放一个汉字国标码。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label7"></a></div><h2 id="bbkbmbgb-的关系">7. b、B、KB、MB、GB 的关系？</h2>
<pre><code class="hljs">
  1024</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label8"></a></div><h2 id="请至少列举5个-pep8-规范越多越好">8. 请至少列举5个 PEP8 规范（越多越好）。</h2>
<pre><code class="hljs groovy">  缩进<span class="hljs-regexp">/空格/</span>注释/命名等
<span class="hljs-symbol">  http:</span><span class="hljs-comment">//blog.sae.sina.com.cn/archives/4781</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label9"></a></div><h2 id="通过代码实现进制转换">9. 通过代码实现进制转换</h2>
<pre><code class="hljs shell"><span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># 二进制转换成十进制：v = “0b1111011”</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># 十进制转换成二进制：v = 18</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># 八进制转换成十进制：v = “011”</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># 十进制转换成八进制：v = 30</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># 十六进制转换成十进制：v = “0x12”</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># 十进制转换成十六进制：v = 87</span></span>
  1) 二进制数、转换为十进制数的规律是:把二进制数按位权形式展开多项式和的形式，求其最后的和，就是其对应的十进制数——简称“按权求和”。
  2) 十进制整数转换为二进制整数采用"除2取余，逆序排列"法。具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。

  10进制，当然是便于我们人类来使用，我们从小的习惯就是使用十进制，这个毋庸置疑。
  2进制，是供计算机使用的，1，0代表开和关，有和无，机器只认识2进制。
  16进制，内存地址空间是用16进制的数据表示, 如0x8039326。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label10"></a></div><h2 id="请编写一个函数实现将ip地址转换成一个整数">10. 请编写一个函数实现将IP地址转换成一个整数。</h2>
<pre><code class="hljs cs">  <span class="hljs-meta">## 如 10.3.9.12 转换规则为：</span>
  <span class="hljs-meta">##         10            00001010</span>
  <span class="hljs-meta">##          3            00000011</span>
  <span class="hljs-meta">##          9            00001001</span>
  <span class="hljs-meta">##         12            00001100</span>
  <span class="hljs-meta">## 再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？</span>


  ip_addr=<span class="hljs-string">'192.168.2.10'</span>
  <span class="hljs-meta"># transfer ip to int</span>
  <span class="hljs-function">def <span class="hljs-title">ip2long</span>(<span class="hljs-params">ip</span>):
      ip_list</span>=ip.split(<span class="hljs-string">'.'</span>)
      result=<span class="hljs-number">0</span>
      <span class="hljs-function"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title">range</span>(<span class="hljs-params"><span class="hljs-number">4</span></span>):  #0,1,2,3
          result</span>=result+<span class="hljs-keyword">int</span>(ip_list[i])*<span class="hljs-number">256</span>**(<span class="hljs-number">3</span>-i)
      <span class="hljs-keyword">return</span> result


  <span class="hljs-keyword">long</span>=<span class="hljs-number">3232236042</span>

  <span class="hljs-meta"># transfer int to ip</span>
  <span class="hljs-function">def <span class="hljs-title">long2ip</span>(<span class="hljs-params"><span class="hljs-keyword">long</span></span>):
      floor_list</span>=[]
      yushu=<span class="hljs-function"><span class="hljs-keyword">long</span>
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title">reversed</span>(<span class="hljs-params">range(<span class="hljs-number">4</span></span>)):   #3,2,1,0
          res</span>=divmod(yushu,<span class="hljs-number">256</span>**i)
          floor_list.append(str(res[<span class="hljs-number">0</span>]))
          yushu=res[<span class="hljs-number">1</span>]
      <span class="hljs-keyword">return</span> <span class="hljs-string">'.'</span>.<span class="hljs-keyword">join</span>(floor_list)



  a=long2ip(<span class="hljs-keyword">long</span>)
  print(a)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label11"></a></div><h2 id="python递归的最大层数">11. python递归的最大层数？</h2>
<pre><code class="hljs">
  998</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label12"></a></div><h2 id="求逻辑运算符的结果">12. 求逻辑运算符的结果</h2>
<pre><code class="hljs shell"><span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     v1 = 1 or 3      # 1</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     v2 = 1 and 3     # 3 </span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     v3 = 0 and 2 and 1  # 0</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     v4 = 0 and 2 or 1   # 1</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     v5 = 0 and 2 or 1 or 4   #  1</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     v6 = 0 or Flase and 1   # False</span></span>

结论：
真假比 若都真
or选前 and选后</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label13"></a></div><h2 id="asciiunicodeutf-8gbk-区别">13. ascii、unicode、utf-8、gbk 区别？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/zhuwenlubin/p/5131026.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label14"></a></div><h2 id="字节码和机器码的区别">14. 字节码和机器码的区别？</h2>
<pre><code class="hljs">  机器码
  机器码(machine code)，学名机器语言指令，有时也被称为原生码（Native Code），是电脑的CPU可直接解读的数据。

  通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。

  用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码和代码的涵义。手编程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态。这是一件十分繁琐的工作，编写程序花费的时间往往是实际运行时间的几十倍或几百倍。而且，编出的程序全是些0和1的指令代码，直观性差，还容易出错。现在，除了计算机生产厂家的专业人员外，绝大多数的程序员已经不再去学习机器语言了。

  机器语言是微处理器理解和使用的，用于控制它的操作二进制代码。
  8086到Pentium的机器语言指令长度可以从1字节到13字节。
  尽管机器语言好像是很复杂的，然而它是有规律的。
  存在着多至100000种机器语言的指令。这意味着不能把这些种类全部列出来。
  总结：机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。

  字节码
  字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。

  通常情况下它是已经经过编译，但与特定机器码无关。字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。

  字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码的典型应用为Java bytecode。

  字节码在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。

  总结：字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label15"></a></div><h2 id="三元运算规则以及应用场景">15. 三元运算规则以及应用场景？</h2>
<pre><code class="hljs javascript">
  简化<span class="hljs-keyword">if</span>语句</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label16"></a></div><h2 id="列举-python2和python3的区别">16. 列举 Python2和Python3的区别？</h2>
<pre><code class="hljs yaml">  <span class="hljs-string">py2和py3:</span>
  <span class="hljs-number">1.</span> <span class="hljs-string">文件操作：</span>  <span class="hljs-string">xreadlines</span>

  <span class="hljs-string">f</span> <span class="hljs-string">=</span> <span class="hljs-string">open('x.log','rb')</span>

  <span class="hljs-string">for</span> <span class="hljs-string">line</span> <span class="hljs-string">in</span> <span class="hljs-string">f.xreadlines():</span>
  <span class="hljs-string">print(line)</span>

  <span class="hljs-string">f.close()</span>

  <span class="hljs-number">2.</span> <span class="hljs-string">字符串：</span>
<span class="hljs-attr">  py2:</span>
<span class="hljs-attr">  str:</span> <span class="hljs-string">字符串</span>   <span class="hljs-bullet">-&gt;</span> <span class="hljs-string">字节</span>
<span class="hljs-attr">  unicode:</span> <span class="hljs-string">u"sdfsdf"</span>
<span class="hljs-attr">  py3:</span>
<span class="hljs-attr">    bytes:</span>
<span class="hljs-attr">  str:</span>
  <span class="hljs-number">3.</span> <span class="hljs-string">默认解释器编码</span>
<span class="hljs-attr">  py2:</span> <span class="hljs-string">ascii</span>
<span class="hljs-attr">  py3:</span> <span class="hljs-string">utf-8</span>

  <span class="hljs-number">5.</span> 
<span class="hljs-attr">  py2:</span> <span class="hljs-string">range/xrange</span> 
<span class="hljs-attr">  py3:</span>       <span class="hljs-string">range</span> 

  <span class="hljs-number">6.</span> 
<span class="hljs-attr">  py2:</span> <span class="hljs-string">int</span> <span class="hljs-string">/</span> <span class="hljs-string">long</span>
<span class="hljs-attr">  py3:</span> <span class="hljs-string">int</span> 

  <span class="hljs-number">7.</span> <span class="hljs-string">input/raw_input</span> 

  <span class="hljs-number">8.</span> 
<span class="hljs-attr">  py2:</span> <span class="hljs-string">yield</span>
<span class="hljs-attr">  py3:</span> <span class="hljs-string">yield/yield</span> <span class="hljs-string">from</span> 

  <span class="hljs-number">9.</span> 
<span class="hljs-attr">  py2:</span> <span class="hljs-string">新式类和经典类</span>
<span class="hljs-attr">  py3:</span> <span class="hljs-string">新式类</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label17"></a></div><h2 id="用一行代码实现数值交换">17. 用一行代码实现数值交换</h2>
<pre><code class="hljs">
  a,b=b,a</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label18"></a></div><h2 id="python3和python2中-int-和-long的区别">18. Python3和Python2中 int 和 long的区别？</h2>
<pre><code class="hljs groovy">
  python3 彻底废弃了 <span class="hljs-keyword">long</span>+<span class="hljs-keyword">int</span> 双整数实现的方法, 统一为 <span class="hljs-keyword">int</span> , 支持高精度整数运算.</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label19"></a></div><h2 id="xrange和range的区别">19. xrange和range的区别？</h2>
<pre><code class="hljs go">
  函数说明：和<span class="hljs-keyword">range</span> 的用法完全相同，但是返回的是一个生成器。 </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label20"></a></div><h2 id="文件操作时xreadlines和readlines的区别">20. 文件操作时：xreadlines和readlines的区别？</h2>
<pre><code class="hljs less">   <span class="hljs-selector-tag">1</span>) <span class="hljs-selector-tag">read</span>([size])方法从文件当前位置起读取<span class="hljs-selector-tag">size</span>个字节，若无参数<span class="hljs-selector-tag">size</span>，则表示读取至文件结束为止，它范围为字符串对象
    <span class="hljs-selector-tag">2</span>) 从字面意思可以看出，该方法每次读出一行内容，所以，读取时占用内存小，比较适合大文件，该方法返回一个字符串对象。
    <span class="hljs-selector-tag">3</span>) <span class="hljs-selector-tag">readlines</span>()方法读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素，但读取大文件会比较占内存。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label21"></a></div><h2 id="列举布尔值为false的常见值">21. 列举布尔值为False的常见值？</h2>
<pre><code class="hljs vbnet">  布尔型，<span class="hljs-literal">False</span>表示<span class="hljs-literal">False</span>，其他为<span class="hljs-literal">True</span>
  整数和浮点数，<span class="hljs-number">0</span>表示<span class="hljs-literal">False</span>，其他为<span class="hljs-literal">True</span>
  字符串和类字符串类型（包括bytes和<span class="hljs-keyword">unicode</span>），空字符串表示<span class="hljs-literal">False</span>，其他为<span class="hljs-literal">True</span>
  序列类型（包括tuple，list，dict，<span class="hljs-keyword">set</span>等），空表示<span class="hljs-literal">False</span>，非空表示<span class="hljs-literal">True</span>
  None永远表示<span class="hljs-literal">False</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label22"></a></div><h2 id="字符串列表元组字典每个常用的5个方法">22. 字符串、列表、元组、字典每个常用的5个方法？</h2>
<pre><code class="hljs sql">  - 字符串  split/strip/<span class="hljs-keyword">replace</span>/find/<span class="hljs-keyword">index</span> ...
  - 列表     append/extend/<span class="hljs-keyword">insert</span>/push/pop/<span class="hljs-keyword">reverse</span>/<span class="hljs-keyword">sort</span> ...
  - 元组     <span class="hljs-keyword">len</span>/<span class="hljs-keyword">max</span>/<span class="hljs-keyword">min</span>/<span class="hljs-keyword">count</span>/<span class="hljs-keyword">index</span> ...
  - 字典     <span class="hljs-keyword">keys</span>/<span class="hljs-keyword">values</span>/pop/<span class="hljs-keyword">clear</span>/del ...
  - 集合　 <span class="hljs-keyword">add</span>/remove/<span class="hljs-keyword">clear</span>/交集&amp;、并集 |、差集 -　
  　
  - collections  Python内建的一个集合模块，提供了许多有用的集合类。
      <span class="hljs-number">1.</span>Counter是一个简单的计数器，例如，统计字符出现的个数;
      2.OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key;
      3.deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈;
      4.defaultdict使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict;</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label23"></a></div><h2 id="lambda表达式格式以及应用场景">23. lambda表达式格式以及应用场景？</h2>
<pre><code class="hljs less">  省去函数命名的烦恼
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/guigujun/p/6134828.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label24"></a></div><h2 id="pass的作用">24. pass的作用？</h2>
<pre><code class="hljs python">
  当你在编写一个程序时，执行语句部分思路还没有完成，这时你可以用<span class="hljs-keyword">pass</span>语句来占位，也可以当做是一个标记，是要过后来完成的代码。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label25"></a></div><h2 id="arg和kwarg作用">25. arg和kwarg作用</h2>
<pre><code class="hljs awk">  *args：（表示的就是将实参中按照位置传值，多出来的值都给args，且以元组的方式呈现）
  **kwargs：（表示的就是形参中按照关键字传值把多余的传值以字典的方式呈现）
  http:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/xuyuanyuan123/</span>p<span class="hljs-regexp">/6674645.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label26"></a></div><h2 id="is和的区别">26. is和==的区别</h2>
<pre><code class="hljs coffeescript">  <span class="hljs-keyword">is</span> 比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。莱布尼茨说过：“世界上没有两片完全相同的叶子”，这个<span class="hljs-keyword">is</span>正是这样的比较，比较是不是同一片叶子（即比较的id是否相同，这id类似于人的身份证标识）。

  == 比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。这里比较的并非是同一片叶子，可能叶子的种类或者脉络相同就可以了。默认会调用对象的 __eq__()方法。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label27"></a></div><h2 id="简述python的深浅拷贝以及应用场景">27. 简述Python的深浅拷贝以及应用场景？</h2>
<pre><code class="hljs dockerfile">  Python采用基于值得内存管理模式，赋值语句的执行过程是：首先把等号右侧标识的表达式计算出来，然后在内存中找一个位置把值存放进去，最后创建变量并指向这个内存地址。Python中的变量并不直接存储值，而是存储了值的内存地址或者引用
  简单地说，浅拷贝只拷贝一层（如果有嵌套），深拷贝拷贝所有层。
  一层的情况：
    import <span class="hljs-keyword">copy</span><span class="bash">

</span>    <span class="hljs-comment"># 浅拷贝</span>

    li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
    li2 = li1.copy()
    li1.append(<span class="hljs-number">4</span>)
    print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, 4] [1, 2, 3]</span>

    <span class="hljs-comment"># 深拷贝</span>

    li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
    li2 = <span class="hljs-keyword">copy</span>.<span class="bash">deepcopy(li1)
</span>    li1.append(<span class="hljs-number">4</span>)
    print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, 4] [1, 2, 3]</span>
  多层的情况：
    import <span class="hljs-keyword">copy</span><span class="bash">

</span>    <span class="hljs-comment"># 浅拷贝</span>

    li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">6</span>]
    li2 = li1.copy()
    li1[<span class="hljs-number">3</span>].append(<span class="hljs-number">7</span>)
    print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5, 7], 6]</span>

    <span class="hljs-comment"># 深拷贝</span>

    li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">6</span>]
    li2 = <span class="hljs-keyword">copy</span>.<span class="bash">deepcopy(li1)
</span>    li1[<span class="hljs-number">3</span>].append(<span class="hljs-number">7</span>)
    print(li1, li2)  <span class="hljs-comment"># [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5], 6]</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label28"></a></div><h2 id="python垃圾回收机制">28. Python垃圾回收机制？</h2>
<pre><code class="hljs verilog">  Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark <span class="hljs-keyword">and</span> sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。

  <span class="hljs-number">1</span> 引用计数

  PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为<span class="hljs-number">0</span>时，该对象生命就结束了。

  优点:

  简单 实时性 缺点:

  维护引用计数消耗资源 循环引用

  <span class="hljs-number">2</span> 标记-清除机制

  基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。

  <span class="hljs-number">3</span> 分代技术

  分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

  Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

  http:<span class="hljs-comment">//python.jobbole.com/82061/</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label29"></a></div><h2 id="python的可变类型和不可变类型">29. Python的可变类型和不可变类型？</h2>
<pre><code class="hljs">  在Python中不可变对象指：一旦创建就不可修改的对象，包括字符串，元组，数字

  在Python中可变对象是指：可以修改的对象，包括：列表、字典</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label30"></a></div><h2 id="求可变数据类型结果">30. 求可变数据类型结果</h2>
<pre><code class="hljs go">  v = dict.fromkeys([<span class="hljs-string">'k1'</span>,<span class="hljs-string">'k2'</span>],[])
  v[<span class="hljs-string">'k1'</span>].<span class="hljs-built_in">append</span>(<span class="hljs-number">666</span>)
  <span class="hljs-built_in">print</span>(v)    # {<span class="hljs-string">'k1'</span>: [<span class="hljs-number">666</span>], <span class="hljs-string">'k2'</span>: [<span class="hljs-number">666</span>]}
  v[<span class="hljs-string">'k1'</span>] = <span class="hljs-number">777</span>
  <span class="hljs-built_in">print</span>(v)    # {<span class="hljs-string">'k1'</span>: <span class="hljs-number">777</span>, <span class="hljs-string">'k2'</span>: [<span class="hljs-number">666</span>]}</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label31"></a></div><h2 id="求匿名函数结果">31. 求匿名函数结果</h2>
<pre><code class="hljs python">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">return</span>[<span class="hljs-keyword">lambda</span> x: i*x <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]

  print([m(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> num()])    <span class="hljs-comment"># [6, 6, 6, 6]</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label32"></a></div><h2 id="列举常见的内置函数">32. 列举常见的内置函数？</h2>
<pre><code class="hljs cs">   <span class="hljs-keyword">long</span>(x)
    <span class="hljs-keyword">float</span>(x)  <span class="hljs-meta"># 把x转换成浮点数</span>
    complex(x) <span class="hljs-meta"># 转换成复数</span>
    str(x)   <span class="hljs-meta"># 转换成字符串</span>
    list(x)  <span class="hljs-meta"># 转换成列表</span>
    tuple(x) <span class="hljs-meta"># 转换成元组</span>
     
    进制相互转换
     r= bin(<span class="hljs-number">10</span>) <span class="hljs-meta">#二进制</span>
     r= <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>) <span class="hljs-meta">#十进制</span>

     r = oct(<span class="hljs-number">10</span>) <span class="hljs-meta">#八进制</span>
     r = hex(<span class="hljs-number">10</span>) <span class="hljs-meta">#十六进制</span>
     i= <span class="hljs-keyword">int</span>(<span class="hljs-string">"11"</span>,<span class="hljs-keyword">base</span>=<span class="hljs-number">10</span>)<span class="hljs-meta">#进制间的相互转换base后跟 2/8/10/16</span>
     print(i)
     
    chr(x)<span class="hljs-comment">//返回x对应的字符，如chr(65)返回‘A'</span>
    ord(x)<span class="hljs-comment">//返回字符对应的ASC码数字编号，如ord('A')返回65</span>
    abs(),all(),any(),bin(),<span class="hljs-keyword">bool</span>(),bytes(),chr(),dict()dir(),divmod(),enumerate(),eval(),filter(),<span class="hljs-keyword">float</span>(),gloabls(),help(),hex(),id(),input(),<span class="hljs-keyword">int</span>(),isinstance(),len(),list(),locals(),map(),max(),min(),oct(),open(),ord(),pow(),print(),range(),round(),<span class="hljs-keyword">set</span>(),type(),sorted(),str(),sum(),tuple()</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label33"></a></div><h2 id="filtermapreduce的作用">33. filter、map、reduce的作用？</h2>
<pre><code class="hljs less">  <span class="hljs-attribute">filter</span>:对于序列中的元素进行筛选，最终获取符合条件的序列
  <span class="hljs-attribute">map</span>:遍历序列，对序列中每个元素进行操作，最终获取新的序列
  <span class="hljs-attribute">reduce</span>:对于序列内所有元素进行累计操作</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label34"></a></div><h2 id="一行代码实现9乘9乘法表">34. 一行代码实现9乘9乘法表</h2>
<pre><code class="hljs swift">
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>.<span class="hljs-built_in">join</span>(<span class="hljs-string">"\t"</span>.<span class="hljs-built_in">join</span>([<span class="hljs-string">"%s*%s=%s"</span> %(x,y,x*y) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, x+<span class="hljs-number">1</span>)]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)) )</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label35"></a></div><h2 id="如何安装第三方模块以及用过哪些第三方模块">35. 如何安装第三方模块？以及用过哪些第三方模块？</h2>
<pre><code class="hljs erlang-repl">  - pip包管理器
  - 源码安装
      - 下载-&gt;解压-&gt;cd 到对应路径
      - python setup.py build
      - python setup.py install </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label36"></a></div><h2 id="常用模块都有哪些">36. 常用模块都有哪些？</h2>
<pre><code class="hljs groovy">
  - re<span class="hljs-regexp">/json/</span>logging<span class="hljs-regexp">/os/</span>sys<span class="hljs-regexp">/requests/</span>beautifulsoup4</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label37"></a></div><h2 id="re的match和search区别">37. re的match和search区别？</h2>
<pre><code class="hljs lua">  <span class="hljs-built_in">match</span>和search的区别

  re.<span class="hljs-built_in">match</span>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
  re.search匹配整个字符串，直到找到一个匹配。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label38"></a></div><h2 id="什么是正则的贪婪匹配">38. 什么是正则的贪婪匹配？</h2>
<pre><code class="hljs javascript">  贪婪和非贪婪
  正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪则相反，总是尝试匹配尽可能少的字符。在<span class="hljs-string">"*"</span>,<span class="hljs-string">"?"</span>,<span class="hljs-string">"+"</span>,<span class="hljs-string">"{m,n}"</span>后面加上？，使贪婪变成非贪婪。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label39"></a></div><h2 id="求结果a.-i-2-for-i-in-range10-b.-i-2-for-i-in-range10">39. 求结果：a. [ i % 2 for i in range(10) ] b. ( i % 2 for i in range(10) )</h2>
<pre><code class="hljs objectivec">  [ i % <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) ]  <span class="hljs-meta"># [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]</span>
  ( i % <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) )  <span class="hljs-meta"># <span class="hljs-meta-string">&lt;generator object &lt;genexpr&gt;</span> at 0x0000000003180FC0&gt;</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label40"></a></div><h2 id="求结果a.-1-or-2-b.-1-and-2-c.-1-22-d.-1-2-2">40. 求结果：a. 1 or 2 b. 1 and 2 c. 1 &lt; (2==2) d. 1 &lt; 2 == 2</h2>
<pre><code class="hljs yaml">  <span class="hljs-number">1</span>
  <span class="hljs-number">2</span>
  <span class="hljs-literal">False</span>
  <span class="hljs-literal">True</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label41"></a></div><h2 id="def-funcab-这种写法有什么坑">41. def func(a,b=[]) 这种写法有什么坑？</h2>
<pre><code class="hljs swift">  def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b=[])</span></span>:
      b.append(a)
      <span class="hljs-keyword">return</span> b
   
   
  s = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>
  <span class="hljs-built_in">print</span>(s)  # [<span class="hljs-number">1</span>]
  s = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>
  <span class="hljs-built_in">print</span>(s)  # [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
   
  # 第二次调用的时候 b的初始值是[<span class="hljs-number">1</span>]了</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label42"></a></div><h2 id="如何实现-123-变成-123">42. 如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</h2>
<pre><code class="hljs less">
  <span class="hljs-selector-tag">list</span>(<span class="hljs-string">"1,2,3"</span>.split(<span class="hljs-string">','</span>))</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label43"></a></div><h2 id="如何实现123变成123">43. 如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</h2>
<pre><code class="hljs groovy">
  [<span class="hljs-keyword">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>]]</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label44"></a></div><h2 id="比较-a-123-和-b-123-以及-b-123-的区别">44. 比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 b = [(1,),(2,),(3,) ] 的区别？</h2>
<pre><code class="hljs go">  前两个列表内是<span class="hljs-keyword">int</span>
  最后一个列表内是元组</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label45"></a></div><h2 id="如何用一行代码生成149162536496481100">45. 如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</h2>
<pre><code class="hljs vhdl">
  i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)]</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label46"></a></div><h2 id="一行代码实现删除列表中重复的值">46. 一行代码实现删除列表中重复的值 ?</h2>
<pre><code class="hljs cpp">
  <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">343</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]))</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label47"></a></div><h2 id="如何在函数中设置一个全局变量">47. 如何在函数中设置一个全局变量 ?</h2>
<pre><code class="hljs verilog">
  在函数中定义的局部变量如果和全局变量同名，则它会隐藏该全局变量。如果想在函数中使用全局变量，则需要使用<span class="hljs-keyword">global</span>进行声明。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label48"></a></div><h2 id="logging模块的作用以及应用场景">48. logging模块的作用？以及应用场景？</h2>
<pre><code class="hljs go">  logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比<span class="hljs-built_in">print</span>，具备如下优点：

    可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；

    <span class="hljs-built_in">print</span>将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出。
    https:<span class="hljs-comment">//www.cnblogs.com/testdjt/p/7834856.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label49"></a></div><h2 id="请用代码简单实现一个栈">49. 请用代码简单实现一个栈。</h2>
<pre><code class="hljs ruby">  <span class="hljs-comment"># 后进先出</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>():</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, size)</span></span>:
          <span class="hljs-keyword">self</span>.size = size
          <span class="hljs-keyword">self</span>.stack = []
          <span class="hljs-keyword">self</span>.top = -<span class="hljs-number">1</span>

      <span class="hljs-comment"># 入栈之前检查栈是否已满</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, x)</span></span>:
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isfull():
              raise exception(<span class="hljs-string">"stack is full"</span>)
          <span class="hljs-symbol">else:</span>
              <span class="hljs-keyword">self</span>.stack.append(x)
              <span class="hljs-keyword">self</span>.top = <span class="hljs-keyword">self</span>.top + <span class="hljs-number">1</span>

      <span class="hljs-comment"># 出栈之前检查栈是否为空</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isempty():
              raise exception(<span class="hljs-string">"stack is empty"</span>)
          <span class="hljs-symbol">else:</span>
              <span class="hljs-keyword">self</span>.top = <span class="hljs-keyword">self</span>.top - <span class="hljs-number">1</span>
              <span class="hljs-keyword">self</span>.stack.pop()

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isfull</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.top + <span class="hljs-number">1</span> == <span class="hljs-keyword">self</span>.size

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isempty</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.top == <span class="hljs-string">'-1'</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showStack</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
          print(<span class="hljs-keyword">self</span>.stack)


  s = Stack(<span class="hljs-number">10</span>)
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):
      s.push(i)  <span class="hljs-comment"># 入栈</span>
  s.showStack()  <span class="hljs-comment"># [0, 1, 2, 3, 4, 5]</span>

  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):
      s.pop()  <span class="hljs-comment"># 出栈</span>
  s.showStack()  <span class="hljs-comment"># [0, 1, 2, 3]</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label50"></a></div><h2 id="常用字符串格式化哪几种">50. 常用字符串格式化哪几种？</h2>
<pre><code class="hljs erlang-repl">
  Python的字符串格式化有两种方式:<span class="hljs-comment">%格式符方式，format方式</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label51"></a></div><h2 id="简述-生成器迭代器可迭代对象-以及应用场景">51. 简述 生成器、迭代器、可迭代对象 以及应用场景？</h2>
<pre><code class="hljs less">  如果给定一个<span class="hljs-selector-tag">list</span>或<span class="hljs-selector-tag">tuple</span>，我们可以通过<span class="hljs-selector-tag">for</span>循环来遍历这个<span class="hljs-selector-tag">list</span>或<span class="hljs-selector-tag">tuple</span>，这种遍历我们称为迭代（<span class="hljs-selector-tag">Iteration</span>）刚才说过，很多容器都是可迭代对象，此外还有更多的对象同样也是可迭代对象，比如处于打开状态的<span class="hljs-selector-tag">files</span>，<span class="hljs-selector-tag">sockets</span>等等。但凡是可以返回一个 迭代器 的对象都可称之为可迭代对象
  那么什么迭代器呢？它是一个带状态的对象，他能在你调用 <span class="hljs-selector-tag">next</span>() 方法的时候返回容器中的下一个值，任何实现了 <span class="hljs-selector-tag">__next__</span>() （<span class="hljs-selector-tag">python2</span>中实现 <span class="hljs-selector-tag">next</span>() ）方法的对象都是迭代器
  生成器算得上是<span class="hljs-selector-tag">Python</span>语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。生成器（<span class="hljs-selector-tag">yield</span>）不需要再像上面的类一样写 <span class="hljs-selector-tag">__iter__</span>() 和 <span class="hljs-selector-tag">__next__</span>() 方法了，只需要一个 <span class="hljs-selector-tag">yiled</span> 关键字。 生成器有如下特征是它一定也是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。
  <span class="hljs-selector-tag">http</span>:<span class="hljs-comment">//www.cnblogs.com/yuanchenqi/articles/5769491.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label52"></a></div><h2 id="用python实现一个二分查找的函数">52. 用Python实现一个二分查找的函数。</h2>
<pre><code class="hljs cs">  <span class="hljs-function">def <span class="hljs-title">bin_search_rec</span>(<span class="hljs-params">data_set, <span class="hljs-keyword">value</span>, low, high</span>):
      <span class="hljs-keyword">if</span> low &lt;</span>= high:
          mid = (low + high) <span class="hljs-comment">// 2</span>
          <span class="hljs-keyword">if</span> data_set[mid] == <span class="hljs-keyword">value</span>:
              <span class="hljs-keyword">return</span> mid
          elif data_set[mid] &gt; <span class="hljs-keyword">value</span>:
              <span class="hljs-keyword">return</span> bin_search_rec(data_set, <span class="hljs-keyword">value</span>, low, mid - <span class="hljs-number">1</span>)
          <span class="hljs-keyword">else</span>:
              <span class="hljs-keyword">return</span> bin_search_rec(data_set, <span class="hljs-keyword">value</span>, mid + <span class="hljs-number">1</span>, high)
      <span class="hljs-keyword">else</span>:
          <span class="hljs-keyword">return</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label53"></a></div><h2 id="谈谈你对闭包的理解">53. 谈谈你对闭包的理解？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/Lin-Yi/p/7305364.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label54"></a></div><h2 id="os和sys模块的作用">54. os和sys模块的作用？</h2>
<pre><code class="hljs lua">  <span class="hljs-built_in">os</span>就是一个普通的python库，用来向Python程序提供运行环境，特别是在文件系统、创建新进程、获取操作系统本身的一些信息（比如uname)，并屏蔽各种不同操作系统之间的细节差异。
  sys模块则是python程序用来请求解释器行为的接口。比如关于调试类的（trace, frames，except）等，profiling类（stats， getsizeof)，运行时环境类（python <span class="hljs-built_in">path</span>, <span class="hljs-built_in">stderr</span>, <span class="hljs-built_in">stdout</span>)，解释器本身（如version）。inspect某种程度上可以看成是在sys提供的功能上的一个包装。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label55"></a></div><h2 id="如何生成一个随机数">55. 如何生成一个随机数？</h2>
<pre><code class="hljs lua">
  <span class="hljs-built_in">random</span>.randint(a,b)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label56"></a></div><h2 id="如何使用python删除一个文件">56. 如何使用python删除一个文件？</h2>
<pre><code class="hljs lua">  删除子目录
  <span class="hljs-built_in">os</span>.rmdir( <span class="hljs-built_in">path</span> )   # <span class="hljs-built_in">path</span>: <span class="hljs-string">"要删除的子目录"</span>

  产生异常的可能原因:
  (<span class="hljs-number">1</span>) <span class="hljs-built_in">path</span> 不存在
  (<span class="hljs-number">2</span>) <span class="hljs-built_in">path</span> 子目录中有文件或下级子目录
  (<span class="hljs-number">3</span>) 没有操作权限或只读

  删除文件
  <span class="hljs-built_in">os</span>.<span class="hljs-built_in">remove</span>(   filename )   # filename: <span class="hljs-string">"要删除的文件名"</span>

  产生异常的可能原因:
  (<span class="hljs-number">1</span>)   filename 不存在
  (<span class="hljs-number">2</span>) 对filename文件， 没有操作权限或只读。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label57"></a></div><h2 id="谈谈你对面向对象的理解">57. 谈谈你对面向对象的理解？</h2>
<pre><code class="hljs ruby">  从三大特性说起：继承、封装、多态
  
  封装：
      起始就是将很多数据封装到一个对象中，类似于把很多东西放到一个箱子中，
      如：一个函数如果好多参数，起始就可以把参数封装到一个对象再传递。
      
      在哪里用过：
        - django rest framework中的request对象。
        - flask中：ctx_context/app_context对象
  继承：
      如果多个类中都有共同的方法，那么为了避免反复编写，就可以将方法提取到基类中实现，
      让所有派生类去继承即可。
      
      在哪里用过？
        - 视图
        - 版本、认证、分页
  多态：
      python本身就是多态的，崇尚鸭子模型，只要会呱呱叫的就是鸭子。
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(arg)</span></span>:
        arg.send()
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/iyouyue</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8535796</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label58"></a></div><h2 id="python面向对象中的继承有什么特点">58. Python面向对象中的继承有什么特点？</h2>
<pre><code class="hljs">  Python3的继承机制
    子类在调用某个方法或变量的时候，首先在自己内部查找，如果没有找到，则开始根据继承机制在父类里查找。
    根据父类定义中的顺序，以深度优先的方式逐一查找父类！
    继承参数的书写有先后顺序，写在前面的被优先继承。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label59"></a></div><h2 id="面向对象深度优先和广度优先是什么">59. 面向对象深度优先和广度优先是什么？</h2>
<pre><code class="hljs less">  继承顺序
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.liujiangblog.com/course/python/44</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label60"></a></div><h2 id="面向对象中super的作用">60. 面向对象中super的作用？</h2>
<pre><code class="hljs ruby">  我们都知道，在子类中如果有与父类同名的成员，那就会覆盖掉父类里的成员。那如果你想强制调用父类的成员呢？使用<span class="hljs-keyword">super</span>()函数！这是一个非常重要的函数，最常见的就是通过<span class="hljs-keyword">super</span>调用父类的实例化方法__init_<span class="hljs-number">_</span>！

  语法：<span class="hljs-keyword">super</span>(子类名, <span class="hljs-keyword">self</span>).方法名()，需要传入的是子类名和<span class="hljs-keyword">self</span>，调用的是父类里的方法，按父类的方法需要传入参数。
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name)</span></span>:
          <span class="hljs-keyword">self</span>.name = name
          print(<span class="hljs-string">"父类的__init__方法被执行了！"</span>)
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
          print(<span class="hljs-string">"父类的show方法被执行了！"</span>)

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-title">A</span>):</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name, age)</span></span>:
          <span class="hljs-keyword">super</span>(B, <span class="hljs-keyword">self</span>).__init_<span class="hljs-number">_</span>(name=name)
          <span class="hljs-keyword">self</span>.age = age

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
          <span class="hljs-keyword">super</span>(B, <span class="hljs-keyword">self</span>).show()

  obj = B(<span class="hljs-string">"jack"</span>, <span class="hljs-number">18</span>)
  obj.show()</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label61"></a></div><h2 id="是否使用过functools中的函数其作用是什么">61. 是否使用过functools中的函数？其作用是什么？</h2>
<pre><code class="hljs go">  <span class="hljs-number">1.f</span>unctools.partial
  官网文档说的真是不好理解,就当作是把一个函数，绑定部分或者全部参数后生成一个新版本的函数
  <span class="hljs-number">2.f</span>unctools.partialwrap
  文档说的比较详细，如果不使用这个wraps，那么原始函数的__name__和__doc__都会丢失
  https:<span class="hljs-comment">//blog.csdn.net/secretx/article/details/51700361</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label62"></a></div><h2 id="列举面向对象中带双下划线的特殊方法如newinit">62. 列举面向对象中带双下划线的特殊方法，如：<strong>new</strong>、<strong>init</strong></h2>
<pre><code class="hljs less">  <span class="hljs-attribute">__init__ </span>:      构造函数，在生成对象时调用
  <span class="hljs-attribute">__del__ </span>:       析构函数，释放对象时使用
  <span class="hljs-attribute">__repr__ </span>:      打印，转换
  <span class="hljs-attribute">__setitem__ </span>:   按照索引赋值
  <span class="hljs-attribute">__getitem__</span>:    按照索引获取值
  <span class="hljs-attribute">__len__</span>:        获得长度
  <span class="hljs-attribute">__cmp__</span>:        比较运算
  <span class="hljs-attribute">__call__</span>:       调用
  <span class="hljs-attribute">__add__</span>:        加运算
  <span class="hljs-attribute">__sub__</span>:        减运算
  <span class="hljs-attribute">__mul__</span>:        乘运算
  <span class="hljs-attribute">__div__</span>:        除运算
  <span class="hljs-attribute">__mod__</span>:        求余运算
  <span class="hljs-attribute">__pow__</span>:        幂
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//ltoddy.github.io/essay/2018/05/27/python-magic-methods.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label63"></a></div><h2 id="如何判断是函数还是方法">63. 如何判断是函数还是方法？</h2>
<pre><code class="hljs python">  print(isinstance(obj.func, FunctionType))   <span class="hljs-comment"># False</span>
  print(isinstance(obj.func, MethodType))    <span class="hljs-comment"># True</span>

  示例:
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span><span class="hljs-params">(object)</span>:</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
          self.name = <span class="hljs-string">'lcg'</span>
   
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span>
          print(self.name)
   
   
  obj = Foo()
  print(obj.func)  <span class="hljs-comment"># &lt;bound method Foo.func of &lt;__main__.Foo object at 0x000001ABC0F15F98&gt;&gt;</span>
   
  print(Foo.func)  <span class="hljs-comment"># &lt;function Foo.func at 0x000001ABC1F45BF8&gt;</span>
   
  <span class="hljs-comment"># ------------------------FunctionType, MethodType------------#</span>
   
   
  <span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> FunctionType, MethodType
   
  obj = Foo()
  print(isinstance(obj.func, FunctionType))  <span class="hljs-comment"># False</span>
  print(isinstance(obj.func, MethodType))  <span class="hljs-comment"># True</span>
   
  print(isinstance(Foo.func, FunctionType))  <span class="hljs-comment"># True</span>
  print(isinstance(Foo.func, MethodType))  <span class="hljs-comment"># False</span>
   
  <span class="hljs-comment"># ------------------------------------------------------------#</span>
  obj = Foo()
  Foo.func(obj)  <span class="hljs-comment"># lcg</span>
   
  obj = Foo()
  obj.func()  <span class="hljs-comment"># lcg</span>
   
  <span class="hljs-string">"""
  注意：
      方法，无需传入self参数
      函数，必须手动传入self参数
  """</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label64"></a></div><h2 id="静态方法和类方法区别">64. 静态方法和类方法区别？</h2>
<pre><code class="hljs python">  classmethod 必须有一个指向类对象的引用作为第一个参数，而 staticmethod 可以没有任何参数

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Num</span>:</span>
      <span class="hljs-comment"># 普通方法：能用Num调用而不能用实例化对象调用   </span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">one</span><span class="hljs-params">()</span>:</span>
          <span class="hljs-keyword">print</span> (<span class="hljs-string">'1'</span>)
   
      <span class="hljs-comment"># 实例方法：能用实例化对象调用而不能用Num调用</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">two</span><span class="hljs-params">(self)</span>:</span>
          <span class="hljs-keyword">print</span> (<span class="hljs-string">'2'</span>)
   
      <span class="hljs-comment"># 静态方法：能用Num和实例化对象调用</span>
<span class="hljs-meta">      @staticmethod </span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">three</span><span class="hljs-params">()</span>:</span>
          <span class="hljs-keyword">print</span> (<span class="hljs-string">'3'</span>)
   
      <span class="hljs-comment"># 类方法：第一个参数cls长什么样不重要，都是指Num类本身，调用时将Num类作为对象隐式地传入方法   </span>
<span class="hljs-meta">      @classmethod </span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span><span class="hljs-params">(cls)</span>:</span>
          cls.three() 
   
  Num.one()          <span class="hljs-comment">#1</span>
  <span class="hljs-comment">#Num.two()         #TypeError: two() missing 1 required positional argument: 'self'</span>
  Num.three()        <span class="hljs-comment">#3</span>
  Num.go()           <span class="hljs-comment">#3</span>
   
  i=Num()                
  <span class="hljs-comment">#i.one()           #TypeError: one() takes 0 positional arguments but 1 was given         </span>
  i.two()            <span class="hljs-comment">#2      </span>
  i.three()          <span class="hljs-comment">#3</span>
  i.go()             <span class="hljs-comment">#3 </span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label65"></a></div><h2 id="列举面向对象中的特殊成员以及应用场景">65. 列举面向对象中的特殊成员以及应用场景</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/bainianminguo/p/8076329.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label66"></a></div><h2 id="能组成多少个互不相同且无重复的三位数">66. 1、2、3、4、5 能组成多少个互不相同且无重复的三位数</h2>
<pre><code class="hljs perl">  i = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">x</span> in range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):
      <span class="hljs-keyword">for</span> <span class="hljs-keyword">y</span> in range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):
          <span class="hljs-keyword">for</span> z in range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):
              <span class="hljs-keyword">if</span> (<span class="hljs-keyword">x</span> != <span class="hljs-keyword">y</span>) <span class="hljs-keyword">and</span> (<span class="hljs-keyword">y</span> != z) <span class="hljs-keyword">and</span> (z != <span class="hljs-keyword">x</span>):
                  i += <span class="hljs-number">1</span>
                  <span class="hljs-keyword">if</span> i % <span class="hljs-number">4</span>:
                      <span class="hljs-keyword">print</span>(<span class="hljs-string">"%d%d%d"</span> % (<span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, z), end=<span class="hljs-string">" | "</span>)
                  <span class="hljs-keyword">else</span>:
                      <span class="hljs-keyword">print</span>(<span class="hljs-string">"%d%d%d"</span> % (<span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, z))
  <span class="hljs-keyword">print</span>(i)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label67"></a></div><h2 id="什么是反射以及应用场景">67. 什么是反射？以及应用场景？</h2>
<pre><code class="hljs groovy">  反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找<span class="hljs-regexp">/获取/</span>删除/添加）成员，一种基于字符串的事件驱动！
<span class="hljs-symbol">  https:</span><span class="hljs-comment">//www.cnblogs.com/vipchenwei/p/6991209.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label68"></a></div><h2 id="metaclass作用以及应用场景">68. metaclass作用？以及应用场景？</h2>
<pre><code class="hljs scala">  metaclass用来指定类是由谁创建的。

  类的metaclass 默认是<span class="hljs-class"><span class="hljs-keyword">type</span><span class="hljs-title">。我们也可以指定类的metaclass值。</span></span>
  http:<span class="hljs-comment">//www.cnblogs.com/0bug/p/8578747.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label69"></a></div><h2 id="用尽量多的方法实现单例模式">69. 用尽量多的方法实现单例模式。</h2>
<pre><code class="hljs less">  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//python.jobbole.com/87294/</span>
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/0bug/p/8576802.html</span>
  常用方式：
      使用模块
      使用 __new__
      使用装饰器（decorator）
      使用元类（metaclass）</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label70"></a></div><h2 id="装饰器的写法以及应用场景">70. 装饰器的写法以及应用场景。</h2>
<pre><code class="hljs python">  装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景。
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer</span><span class="hljs-params">(func)</span>:</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(*args,**kwargs)</span>:</span>
          print(<span class="hljs-string">"认证成功！"</span>)
          result = func(*args,**kwargs)
          print(<span class="hljs-string">"日志添加成功"</span>)
          <span class="hljs-keyword">return</span> result
      <span class="hljs-keyword">return</span> inner

<span class="hljs-meta">  @outer</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(name,age)</span>:</span>
      print(<span class="hljs-string">"%s 正在连接业务部门1数据接口......"</span>%name)

  <span class="hljs-comment"># 调用方法</span>
  f1(<span class="hljs-string">"jack"</span>,<span class="hljs-number">18</span>)
  http://www.cnblogs.com/iyouyue/p/<span class="hljs-number">8934547.</span>html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label71"></a></div><h2 id="异常处理写法以及如何主动跑出异常应用场景">71. 异常处理写法以及如何主动跑出异常（应用场景）</h2>
<pre><code class="hljs python">  <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
    <span class="hljs-keyword">try</span>:
        x = int(input(<span class="hljs-string">"Please enter a number: "</span>))
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">except</span> ValueError:
        print(<span class="hljs-string">"Oops!  That was no valid number.  Try again   "</span>)


  <span class="hljs-keyword">raise</span>主动抛出一个异常
  http://www.runoob.com/python3/python3-errors-execptions.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label72"></a></div><h2 id="什么是面向对象的mro">72. 什么是面向对象的mro</h2>
<pre><code class="hljs groovy">  mro就是方法解析顺序。
  方法解析顺序Method Resolution Order
  参考：<span class="hljs-string">http:</span><span class="hljs-comment">//www.cnblogs.com/0bug/p/8728570.html#_label8</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label73"></a></div><h2 id="isinstance作用以及应用场景">73. isinstance作用以及应用场景？</h2>
<pre><code class="hljs python">  用于判断一个对象是否是一个类或者其子类的实例。
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
      <span class="hljs-keyword">pass</span>
   
   
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">b</span><span class="hljs-params">(A)</span>:</span>
      <span class="hljs-keyword">pass</span>
   
   
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c</span><span class="hljs-params">(b)</span>:</span>
      <span class="hljs-keyword">pass</span>
   
   
  bb = b()
   
  print(isinstance(bb, A))  <span class="hljs-comment"># True</span>
  print(isinstance(bb, b))  <span class="hljs-comment"># True</span>
  print(isinstance(bb, c))  <span class="hljs-comment"># False</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label74"></a></div><h2 id="写代码并实现leetcode两数之和">74. 写代码并实现LeetCode两数之和：</h2>
<pre><code class="hljs python">  <span class="hljs-comment">## Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would </span>
  <span class="hljs-comment">## have exactly one solution, and you may not use the same element twice.</span>
  <span class="hljs-comment">## Example:</span> 
  <span class="hljs-comment">##           Given nums = [2, 7, 11, 15], target = 9,</span>
  <span class="hljs-comment">##            </span> Because nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> + <span class="hljs-number">7</span> = <span class="hljs-number">9</span>,
  <span class="hljs-comment">##            return [0, 1]</span>


  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>  
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self,nums, target)</span>:</span>
        <span class="hljs-string">""" 
        :type nums: List[int] 
        :type target: int 
        :rtype: List[int] 
        """</span>  
        <span class="hljs-comment">#用len()方法取得nums列表长度  </span>
        n = len(nums)  
        <span class="hljs-comment">#x从0到n取值（不包括n）  </span>
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(n):  
            a = target - nums[x]  
            <span class="hljs-comment">#用in关键字查询nums列表中是否有a  </span>
            <span class="hljs-keyword">if</span> a <span class="hljs-keyword">in</span> nums:  
                <span class="hljs-comment">#用index函数取得a的值在nums列表中的索引  </span>
                y = nums.index(a)  
                <span class="hljs-comment">#假如x=y,那么就跳过,否则返回x,y  </span>
                <span class="hljs-keyword">if</span> x == y:  
                    <span class="hljs-keyword">continue</span>  
                <span class="hljs-keyword">else</span>:  
                    <span class="hljs-keyword">return</span> x,y  
                    <span class="hljs-keyword">break</span>  
            <span class="hljs-keyword">else</span> :  
                <span class="hljs-keyword">continue</span>  
  https://blog.csdn.net/linfeng886/article/details/<span class="hljs-number">79772348</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label75"></a></div><h2 id="json序列化时可以处理的数据类型有哪些如何定制支持datetime类型">75. json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</h2>
<pre><code class="hljs haskell">  <span class="hljs-keyword">import</span> json
  from json <span class="hljs-keyword">import</span> JSONEncoder
  from datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-class">  <span class="hljs-keyword">class</span> <span class="hljs-type">ComplexEncoder</span>(<span class="hljs-type">JSONEncoder</span>):
      def default(<span class="hljs-title">self</span>, <span class="hljs-title">obj</span>):
          if isinstance(<span class="hljs-title">obj</span>, <span class="hljs-title">datetime</span>):
              return obj.strftime('%<span class="hljs-type">Y</span>-%<span class="hljs-title">m</span>-%<span class="hljs-title">d</span> %<span class="hljs-type">H</span>:%<span class="hljs-type">M</span>:%<span class="hljs-type">S</span>')
          else:
              return super(<span class="hljs-type">ComplexEncoder</span>,<span class="hljs-title">self</span>).default(<span class="hljs-title">obj</span>)
  d = { 'name':'alex','data':datetime.now()}
  print(<span class="hljs-title">json</span>.<span class="hljs-title">dumps</span>(<span class="hljs-title">d</span>,<span class="hljs-title">cls</span>=<span class="hljs-type">ComplexEncoder</span>))
  # {"name": "alex", "data": "2018-05-18 19:52:05"}

  https://www.cnblogs.com/tkqasn/p/6005025.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label76"></a></div><h2 id="json序列化时默认遇到中文会转换成unicode如果想要保留中文怎么办">76. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？</h2>
<pre><code class="hljs vbnet">
  在序列化时，中文汉字总是被转换为<span class="hljs-keyword">unicode</span>码，在dumps函数中添加参数ensure_ascii=<span class="hljs-literal">False</span>即可解决。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label77"></a></div><h2 id="什么是断言应用场景">77. 什么是断言？应用场景？</h2>
<pre><code class="hljs lua">  python <span class="hljs-built_in">assert</span>断言是声明其布尔值必须为真的判定，如果发生异常就说明表达示为假

  比如我想测试 a==<span class="hljs-number">1</span>。就可以用断言。如果我的猜想错误就会抛出异常，可以用于测试一段表达式是否成立。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label78"></a></div><h2 id="有用过with-statement吗它的好处是什么">78. 有用过with statement吗？它的好处是什么？</h2>
<pre><code class="hljs javascript">
  <span class="hljs-keyword">with</span>语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label79"></a></div><h2 id="使用代码实现查看列举目录下的所有文件">79. 使用代码实现查看列举目录下的所有文件。</h2>
<pre><code class="hljs lua">  # 方法一：（不使用<span class="hljs-built_in">os</span>.walk）
  def print_directory_contents(sPath):
      import <span class="hljs-built_in">os</span>

      <span class="hljs-keyword">for</span> sChild <span class="hljs-keyword">in</span> <span class="hljs-built_in">os</span>.listdir(sPath):
          sChildPath = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(sPath, sChild)
          <span class="hljs-keyword">if</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(sChildPath):
              print_directory_contents(sChildPath)
          <span class="hljs-keyword">else</span>:
              <span class="hljs-built_in">print</span>(sChildPath)
              
  # 方法二：（使用<span class="hljs-built_in">os</span>.walk）
  def print_directory_contents(sPath):
      import <span class="hljs-built_in">os</span>
      <span class="hljs-keyword">for</span> root, _, filenames <span class="hljs-keyword">in</span> <span class="hljs-built_in">os</span>.walk(sPath):
          <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:
              <span class="hljs-built_in">print</span>(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(root, filename)))


  print_directory_contents(<span class="hljs-string">'已知路径'</span>)

  sPath<span class="hljs-comment">-- 是你所要便利的目录的地址, 返回的是一个三元组(root,dirs,files)。</span>
      root 所指的是当前正在遍历的这个文件夹的本身的地址
      _ 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)
      filenames 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)   </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label80"></a></div><h2 id="简述-yield和yield-from关键字">80. 简述 yield和yield from关键字。</h2>
<pre><code class="hljs awk">
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/chenbin520/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">78111399</span>?locationNum=<span class="hljs-number">7</span>&amp;fps=<span class="hljs-number">1</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label81"></a></div><h2 id="第二部分-网络编程和并发34题">===============第二部分 网络编程和并发（34题）===============</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label82"></a></div><h2 id="简述-osi-七层协议">1. 简述 OSI 七层协议。</h2>
<pre><code class="hljs swift">  a) 四层协议：应用层、传输层、网络层、网络接口层

  b) 五层协议：

  应用层：用户使用的应用程序都归属于应用层，作用为规定应用程序的数据格式。

  传输层：网络层帮我们找到主机，但是区分应用层的应用就是靠端口，所以传输层就是建立端口到端口的通信。（端口范围<span class="hljs-number">0</span>-<span class="hljs-number">65535</span>，<span class="hljs-number">0</span>-<span class="hljs-number">1023</span>为系统占用端口）

  网络层：区分不同的广播域或者子网（否则发送一条数据全世界都会受到，是灾难）。

  数据链路层：定义电信号的分组方式。

  物理层：基于电器特性发送高低点电压（电信号），高电压对应数字<span class="hljs-number">1</span>，低电压对应数字<span class="hljs-number">0</span>。

  <span class="hljs-built_in">c</span>）七层协议：（应用层、表示层、会话层）、传输层、网络层、（数据链路层、物理层）</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label83"></a></div><h2 id="什么是cs和bs架构">2. 什么是C/S和B/S架构？</h2>
<pre><code class="hljs groovy">  <span class="hljs-number">1.</span>什么是C/S结构
  C<span class="hljs-regexp">/S （Client/</span>Server）结构，即客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。
  C/S结构可以看做是胖客户端架构。客户端实现绝大多数的业务逻辑处理和界面展示，作为客户端的部分需要承受很大的压力，从分利用客户端的资源，对客户机的要求较高。
  其实现可以是客户端包含一个或多个在用户的电脑上运行的程序，而服务器端有两种，一种是数据库服务器端，客户端通过数据库连接访问服务器端的数据；另一种是Socket服务器端，服务器端的程序通过Socket与客户端的程序通信。
  目前大多数应用软件系统都是Client<span class="hljs-regexp">/Server形式的两层结构，由于现在的软件应用系统正在向分布式的Web应用发展，Web和Client/</span>Server 应用都可以进行同样的业务处理，应用不同的模块共享逻辑组件；因此，内部的和外部的用户都可以访问新的和现有的应用系统，通过现有应用系统中的逻辑可以扩展出新的应用系统。这也就是目前应用系统的发展方向。
  传统的C／S体系结构虽然采用的是开放模式，但这只是系统开发一级的开放性，在特定的应用中无论是Client端还是Server端都还需要特定的软件支持。由于没能提供用户真正期望的开放环境，C/S结构的软件需要针对不同的操作系统系统开发不同版本的软件，加之产品的更新换代十分快，已经很难适应百台电脑以上局域网用户同时使用。而且代价高， 效率低。

  <span class="hljs-number">2.</span>什么是B/S结构
  B<span class="hljs-regexp">/S（Browser/</span>Server）结构即浏览器和服务器结构。它是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户工作界面是通过WWW浏览器来实现，极少部分事务逻辑在前端（Browser）实现，但是主要事务逻辑在服务器端（Server）实现，形成所谓三层<span class="hljs-number">3</span>-tier结构。这样就大大简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本（TCO）。
  B<span class="hljs-regexp">/S结构可以看作是瘦客户端，只是把显示的较少的逻辑交给了Web浏览器，事务逻辑数据处理在放在了Server端，这样就避免了庞大的胖客户端，减少了客户端的压力。B/</span>S结构的系统无须特别安装，只有Web浏览器即可。当然AJAX\Flex等等的普遍使用也有富客户端的发展方向。
  以目前的技术看，局域网建立B<span class="hljs-regexp">/S结构的网络应用，并通过Internet/</span>Intranet模式下数据库应用，相对易于把握、成本也是较低的。它是一次性到位的开发，能实现不同的人员，从不同的地点，以不同的接入方式（比如LAN, WAN, Internet<span class="hljs-regexp">/Intranet等）访问和操作共同的数据库；它能有效地保护数据平台和管理访问权限，服务器数据库也很安全 。特别是在JAVA这样的跨平台语言出现之后，B/</span>S架构管理软件更是方便、快捷、高效。
<span class="hljs-symbol">  https:</span><span class="hljs-comment">//blog.csdn.net/sinat_35111396/article/details/51535784</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label84"></a></div><h2 id="简述-三次握手四次挥手的流程">3. 简述 三次握手、四次挥手的流程。</h2>
<pre><code class="hljs erlang">  <span class="hljs-number">1</span> 三次握手
  客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。
  服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+<span class="hljs-number">1</span>，SYN/ACK 包本身又有一个随机序号 B。
  最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+<span class="hljs-number">1</span>，而响应则为 B+<span class="hljs-number">1</span>。
  <span class="hljs-number">2</span> 四次挥手
  注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.

  客户端发送一个数据分段, 其中的 FIN 标记设置为<span class="hljs-number">1</span>. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.
  服务器接收到带有 FIN = <span class="hljs-number">1</span> 的数据分段, 发送带有 ACK = <span class="hljs-number">1</span> 的剩余数据分段, 确认收到客户端发来的 FIN 信息.
  服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = <span class="hljs-number">1</span> 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = <span class="hljs-number">1</span> 的确认报文.
  客户端收到服务器发来带有 FIN = <span class="hljs-number">1</span> 的报文, 返回 ACK = <span class="hljs-number">1</span> 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 <span class="hljs-number">2</span>MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.
  图解: http://blog.csdn.net/whuslei/article/details/<span class="hljs-number">6667471</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label85"></a></div><h2 id="什么是arp协议">4. 什么是arp协议？</h2>
<pre><code class="hljs ruby">  ARP协议，全称“Address Resolution Protocol”,中文名是地址解析协议，使用ARP协议可实现通过IP地址获得对应主机的物理地址（MAC地址）。
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/luchuangao</span><span class="hljs-regexp">/articles/</span><span class="hljs-number">6053742</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label86"></a></div><h2 id="tcp和udp的区别">5. TCP和UDP的区别？</h2>
<pre><code class="hljs less">  <span class="hljs-selector-tag">TCP</span>
  收发两端（客户端和服务器端）都要有成对的<span class="hljs-selector-tag">socket</span>，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法(Nagle算法)，将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样接收端就难于分辨，必须提供拆包机制。
  如果利用<span class="hljs-selector-tag">TCP</span>每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题(因为只有一种包结构,类似于http协议)。关闭连接主要要双方都发送<span class="hljs-selector-tag">close</span>连接。
  如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储即可，也不用考虑粘包
  如果双方建立连接，需要在连接后一段时间内发送不同结构数据，就需要考虑粘包问题。所以一般可能会在头加一个数据长度之类的包，以确保接收。
  <span class="hljs-selector-tag">UDP</span>
  对于<span class="hljs-selector-tag">UDP</span>，不会使用块的合并优化算法。实际上目前认为，是由于<span class="hljs-selector-tag">UDP</span>支持的是一对多的模式(注意区分不是并发模式)，所以接收端的<span class="hljs-selector-tag">skbuff</span>(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中有消息头（消息来源地址，端口等信息），这样对于接收端来说，就容易进行区分处理了，所以UDP不会出现粘包问题。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label87"></a></div><h2 id="什么是局域网和广域网">6. 什么是局域网和广域网？</h2>
<pre><code class="hljs delphi">  一、局域网
  局域网（<span class="hljs-keyword">Local</span> Area Network），简称LAN，是指在某一区域内由多台计算机互联成的计算机组。“某一区域”指的是同一办公室、同一建筑物、同一公司和同一学校等，一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、扫描仪共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 
  二、广域网 
  广域网（Wide Area Network），简称WAN，是一种跨越大的、地域性的计算机网络的集合。通常跨越省、市，甚至一个国家。广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网。 
  三、局域网和广域网的区别 
  局域网是在某一区域内的，而广域网要跨越较大的地域，那么如何来界定这个区域呢？例如，一家大型公司的总公司位于北京，而分公司遍布全国各地，如果该公司将所有的分公司都通过网络联接在一起，那么一个分公司就是一个局域网，而整个总公司网络就是一个广域网。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label88"></a></div><h2 id="为何基于tcp协议的通信比基于udp协议的通信更可靠">7. 为何基于tcp协议的通信比基于udp协议的通信更可靠？</h2>
<pre><code class="hljs less">  <span class="hljs-attribute">tcp</span>:可靠 对方给了确认收到信息，才发下一个，如果没收到确认信息就重发
  <span class="hljs-attribute">udp</span>:不可靠 一直发数据，不需要对方回应</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label89"></a></div><h2 id="什么是socket简述基于tcp协议的套接字通信流程">8. 什么是socket？简述基于tcp协议的套接字通信流程。</h2>
<pre><code class="hljs perl">  Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。

  服务端：创建<span class="hljs-keyword">socket</span>对象，绑定ip端口<span class="hljs-keyword">bind</span>(),  设置最大链接数<span class="hljs-keyword">listen</span>(),  <span class="hljs-keyword">accept</span>()与客户端的<span class="hljs-keyword">connect</span>()创建双向管道， <span class="hljs-keyword">send</span>(), <span class="hljs-keyword">recv</span>(),<span class="hljs-keyword">close</span>()

  客户端：创建<span class="hljs-keyword">socket</span>对象，<span class="hljs-keyword">connect</span>()与服务端<span class="hljs-keyword">accept</span>()创建双向管道 ,  <span class="hljs-keyword">send</span>(), <span class="hljs-keyword">recv</span>(),<span class="hljs-keyword">close</span>()</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label90"></a></div><h2 id="什么是粘包-socket-中造成粘包的原因是什么">9. 什么是粘包？ socket 中造成粘包的原因是什么？</h2>
<pre><code class="hljs">  粘包：数据粘在一起，主要因为：接收方不知道消息之间的界限，不知道一次性提取多少字节的数据造成的
  数据量比较小，时间间隔比较短，就合并成了一个包，这是底层的一个优化算法（Nagle算法）</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label91"></a></div><h2 id="io多路复用的作用">10. IO多路复用的作用？</h2>
<pre><code class="hljs lua">  I/O multiplexing就是所谓的<span class="hljs-built_in">select</span>，poll，epoll，也称这种I/O方式为事件驱动I/O(event driven I/O)。
    <span class="hljs-built_in">select</span>/epoll的好处就在于单个进程就可以同时处理多个网络连接的I/O。  它的基本原理就是<span class="hljs-built_in">select</span>/poll/epoll这个<span class="hljs-function"><span class="hljs-keyword">function</span>会不断的轮询所负责的所有<span class="hljs-title">socket</span>，当某个<span class="hljs-title">socket</span>有数据到达了，就通知用户进程。
  <span class="hljs-title">I</span>/<span class="hljs-title">O</span> 多路复用的特点是通过一种机制使一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<span class="hljs-title">select</span><span class="hljs-params">()</span></span>函数就可以返回。

  多道技术的实现就是为了解决多个程序竞争或者共享同一个资源（比如cpu）的有序调度问题，解决方式即是多路复用。多路复用分为时间上的复用和空间上的复用，空间上的多路复用是指将内存分为几部分，每一部分放一个程序，这样同一时间内存中就有多道程序，前提保证内存是分割；时间上的多路复用是指多个程序需要在一个cpu上运行，不同的程序轮流使用cpu，当某个程序运行的时间过长或者遇到I/O阻塞，操作系统会把cpu分配给下一个程序，保证cpu处于高使用率，实现伪并发。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label92"></a></div><h2 id="什么是防火墙以及作用">11. 什么是防火墙以及作用？</h2>
<pre><code class="hljs awk">
  http:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/loneywang/</span>archive<span class="hljs-regexp">/2007/</span><span class="hljs-number">09</span><span class="hljs-regexp">/30/</span><span class="hljs-number">912029</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label93"></a></div><h2 id="selectpollepoll-模型的区别">12. select、poll、epoll 模型的区别？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/Anker/p/3265058.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label94"></a></div><h2 id="简述-进程线程协程的区别-以及应用场景">13. 简述 进程、线程、协程的区别 以及应用场景？</h2>
<pre><code class="hljs go">  什么是进程
  进程（有时称为重量级进程）是一个执行中的程序。每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。同一个程序执行两次，属于是两个不同进程。
  什么是线程
    线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。
    就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机； 运行状态是指线程占有处理机正在运行；
    阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。
  什么是协程
    协程是“微线程”，并非实际存在；是由程序员人为创造出来并控制程序：先执行某段代码、再跳到某处执行某段代码。
  如果遇到非IO请求来回切换：性能更低。
  如果遇到IO（耗时）请求来回切换：性能高、实现并发（本质上利用IO等待的过程，再去干一些其他的事）

  进程池与线程池
  基于多进程或多线程实现并发的套接字通信，然而这种方式的缺陷是：服务的开启的进程数或线程数都会随着并发的客户端数目地增多而增多，这对服务端主机带来巨大的压力，于是必须对服务端开启的进程数或线程数加以控制，让机器在一个自己可以承受的范围内运行，这就是进程池或线程池的用途，例如进程池，就是用来存放进程的池子，本质还是基于多进程，只不过是对开启进程的数目加上了限制。

  <span class="hljs-number">1</span>、进程和线程的区别？

  答：进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。

  比如：开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。通俗的讲：“进程是爹妈，管着众多的线程儿子”。

  参考自：https:<span class="hljs-comment">//www.zhihu.com/question/25532384</span>

  <span class="hljs-number">2</span>、为什么说python的线程是伪线程？

  答：在python的原始解释器CPython中存在着GIL（Global Interpreter Lock，全局解释器锁），因此在解释执行python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GIL。

  所以，虽然CPython的线程库直接封装了系统的原生线程，但CPython整体作为一个进程，同一时间只会有一个线程在跑，其他线程则处于等待状态。这就造成了即使在多核CPU中，多线程也只是做着分时切换而已。

  参考自：https:<span class="hljs-comment">//www.zhihu.com/question/23474039</span>

  <span class="hljs-number">3</span>、python的<span class="hljs-built_in">append</span>和extend有什么区别？

  答：extend()接受一个列表参数，把参数列表的元素添加到列表的尾部，<span class="hljs-built_in">append</span>()接受一个对象参数，把对象添加到列表的尾部。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label95"></a></div><h2 id="gil锁是什么鬼">14. GIL锁是什么鬼？</h2>
<pre><code class="hljs lua">  线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于<span class="hljs-built_in">io</span>密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。

  解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label96"></a></div><h2 id="python中如何使用线程池和进程池">15. Python中如何使用线程池和进程池？</h2>
<pre><code class="hljs awk">  进程池：就是在一个进程内控制一定个数的线程
  基于concurent.future模块的进程池和线程池 （他们的同步执行和异步执行是一样的）
  http:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/haiyan123/</span>p<span class="hljs-regexp">/7461294.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label97"></a></div><h2 id="threading.local的作用">16. threading.local的作用？</h2>
<pre><code class="hljs python">    a. threading.local
    作用：为每个线程开辟一块空间进行数据存储。

    问题：自己通过字典创建一个类似于threading.local的东西。
        storage={
            <span class="hljs-number">4740</span>:{val:<span class="hljs-number">0</span>},
            <span class="hljs-number">4732</span>:{val:<span class="hljs-number">1</span>},
            <span class="hljs-number">4731</span>:{val:<span class="hljs-number">3</span>},
            ...
        }

    b. 自定义Local对象
    作用：为每个线程(协程)开辟一块空间进行数据存储。

        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">from</span> greenlet <span class="hljs-keyword">import</span> getcurrent <span class="hljs-keyword">as</span> get_ident
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> get_ident

        <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
        <span class="hljs-keyword">import</span> time

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Local</span><span class="hljs-params">(object)</span>:</span>

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
                object.__setattr__(self,<span class="hljs-string">'storage'</span>,{})

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span><span class="hljs-params">(self, k, v)</span>:</span>
                ident = get_ident()
                <span class="hljs-keyword">if</span> ident <span class="hljs-keyword">in</span> self.storage:
                    self.storage[ident][k] = v
                <span class="hljs-keyword">else</span>:
                    self.storage[ident] = {k: v}

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, k)</span>:</span>
                ident = get_ident()
                <span class="hljs-keyword">return</span> self.storage[ident][k]

        obj = Local()

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span><span class="hljs-params">(arg)</span>:</span>
            obj.val = arg
            obj.xxx = arg
            print(obj.val)

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
            t = Thread(target=task,args=(i,))
            t.start()</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label98"></a></div><h2 id="进程之间如何进行通信">17. 进程之间如何进行通信？</h2>
<pre><code class="hljs erlang">  进程间通信主要包括管道, 系统IPC（包括消息队列,信号,共享存储), 套接字(SOCKET).
  管道包括三种:
    <span class="hljs-number">1</span>)普通管道PIPE, 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.
    <span class="hljs-number">2</span>)流管道s_pipe: 去除了第一种限制,为半双工，可以双向传输.
    <span class="hljs-number">3</span>)命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label99"></a></div><h2 id="什么是并发和并行">18. 什么是并发和并行？</h2>
<pre><code class="hljs">  如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。
  在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。
  我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。

  摘自：《并发的艺术》 — 〔美〕布雷谢斯</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label100"></a></div><h2 id="进程锁和线程锁的作用">19. 进程锁和线程锁的作用？</h2>
<pre><code class="hljs ruby">  线程锁<span class="hljs-symbol">:</span>大家都不陌生，主要用来给方法、代码块加锁。当某个方法或者代码块使用锁时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。

  进程锁<span class="hljs-symbol">:</span>也是为了控制同一操作系统中多个进程访问一个共享资源，只是因为程序的独立性，各个进程是无法控制其他进程对资源的访问的，但是可以使用本地系统的信号量控制（操作系统基本知识）。

  分布式锁<span class="hljs-symbol">:</span>当多个进程不在同一个系统之中时，使用分布式锁控制多个进程对资源的访问。

  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/intsmaze</span><span class="hljs-regexp">/p/</span><span class="hljs-number">6384105</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label101"></a></div><h2 id="解释什么是异步非阻塞">20. 解释什么是异步非阻塞？</h2>
<pre><code class="hljs">  同步异步指的是在客户端
  同步意味着客户端提出了一个请求以后，在回应之前只能等待
  异步意味着 客户端提出一个请求以后，还可以继续提其他请求阻塞

  非阻塞 指的是服务器端
  阻塞意味着服务器接受一个请求后，在返回结果以前不能接受其他请求
  非阻塞意味着服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label102"></a></div><h2 id="路由器和交换机的区别">21. 路由器和交换机的区别？</h2>
<pre><code class="hljs less">  交换机工作于数据链路层，用来隔离冲突域，连接的所有设备同属于一个广播域（子网），负责子网内部通信。

  路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.zhihu.com/question/20465477</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label103"></a></div><h2 id="什么是域名解析">22. 什么是域名解析？</h2>
<pre><code class="hljs">
  域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label104"></a></div><h2 id="如何修改本地hosts文件">23. 如何修改本地hosts文件？</h2>
<pre><code class="hljs erlang-repl">  <span class="hljs-number">1</span>）hosts文件的位置：C:\windows\system32\drivers\etc，文件夹中找到Hosts文件并用记事本打开。

  <span class="hljs-number">2</span>）按照 ip地址  域名 的格式添加单独的一行记录。例如
  <span class="hljs-number">112.124</span>.<span class="hljs-number">39.29</span> www.server110.com
  注意，IP地址前面不要有空格，ip地址和域名之间，要有至少<span class="hljs-number">1</span>个空格。
  修改后，一定要记得保存文件。

  <span class="hljs-number">3</span>）如何知道域名的IP地址已经生效？
  在您的电脑上请按如下步骤操作：开始--&gt;运行--&gt;输入cmd--&gt;ping 域名--&gt;回车查看结果
  显示结果类似 Reply from <span class="hljs-number">220.181</span>.<span class="hljs-number">31.183</span>: bytes=<span class="hljs-number">32</span> time=<span class="hljs-number">79</span>ms TTL=<span class="hljs-number">53</span>
  中间的  <span class="hljs-number">220.181</span>.<span class="hljs-number">31.183</span> 就是域名的IP地址

  * 注意：有些浏览器会保存DNS缓存，比如Chrome。多按几次F5刷新即可。
  https://www.cnblogs.com/cl-blogs/p/<span class="hljs-number">4160483</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label105"></a></div><h2 id="生产者消费者模型应用场景及优势">24. 生产者消费者模型应用场景及优势？</h2>
<pre><code class="hljs less">  生产者消费者模型

  在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。

    为什么要使用生产者和消费者模式

  在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。

    什么是生产者消费者模式

  生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/huchong/p/7454756.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label106"></a></div><h2 id="什么是cdn">25. 什么是CDN？</h2>
<pre><code class="hljs scss">  CDN主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，比如说，是北京的用户，我们让他访问北京的节点，深圳的用户，我们让他访问深圳的节点。通过就近访问，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。
  CDN的全称是<span class="hljs-attribute">Content</span> Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label107"></a></div><h2 id="lvs是什么及作用">26. LVS是什么及作用？</h2>
<pre><code class="hljs sql">  LVS 是 Linux  Virtual Server ，Linux 虚拟服务器；是一个虚拟的服务器集群【多台机器 LB IP】。LVS 集群分为三层结构:

  1) 负载调度器(<span class="hljs-keyword">load</span> balancer)：它是整个LVS 集群对外的前端机器，负责将<span class="hljs-keyword">client</span>请求发送到一组服务器[多台LB IP]上执行，而<span class="hljs-keyword">client</span>端认为是返回来一个同一个IP【通常把这个IP 称为虚拟IP/VIP】
  <span class="hljs-number">2</span>) 服务器池(<span class="hljs-keyword">server</span> pool)：一组真正执行<span class="hljs-keyword">client</span> 请求的服务器，一般是我们的web服务器；除了web，还有<span class="hljs-keyword">FTP</span>，MAIL，DNS
  <span class="hljs-number">3</span>) 共享存储(<span class="hljs-keyword">shared</span> <span class="hljs-keyword">stored</span>)：它为 <span class="hljs-keyword">server</span> pool 提供了一个共享的存储区，很容易让服务器池拥有相同的内容，提供相同的服务[不是很理解]

  https://blog.csdn.net/caoshuming_500/article/details/<span class="hljs-number">8291940</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label108"></a></div><h2 id="nginx是什么及作用">27. Nginx是什么及作用？</h2>
<pre><code class="hljs awk">  Nginx是一个轻量级、高性能、稳定性高、并发性好的HTTP和反向代理服务器。
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/b9x__/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">80400697</span>
  https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/xiohao/</span>p<span class="hljs-regexp">/6433401.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label109"></a></div><h2 id="keepalived是什么及作用">28. keepalived是什么及作用?</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//baike.baidu.com/item/Keepalived/10346758?fr=aladdin</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label110"></a></div><h2 id="haproxy是什么以及作用">29. haproxy是什么以及作用？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//baike.baidu.com/item/haproxy/5825820</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label111"></a></div><h2 id="什么是负载均衡">30. 什么是负载均衡？</h2>
<pre><code class="hljs perl">  负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。
  负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。
  https:<span class="hljs-regexp">//baike</span>.baidu.com/item/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label112"></a></div><h2 id="什么是rpc及应用场景">31.什么是RPC及应用场景？</h2>
<pre><code class="hljs delphi">  RPC（Remote <span class="hljs-function"><span class="hljs-keyword">Procedure</span> <span class="hljs-title">Call</span>）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<span class="hljs-title">RPC</span>协议假定某些传输协议的存在，如<span class="hljs-title">TCP</span>或<span class="hljs-title">UDP</span>，为通信程序之间携带信息数据。在<span class="hljs-title">OSI</span>网络通信模型中，<span class="hljs-title">RPC</span>跨越了传输层和应用层。<span class="hljs-title">RPC</span>使得开发包括网络分布式多程序在内的应用程序更加容易。
  <span class="hljs-title">RPC</span>采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label113"></a></div><h2 id="简述-asynio模块的作用和应用场景">32.简述 asynio模块的作用和应用场景。</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/zhaof/p/8490045.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label114"></a></div><h2 id="简述-gevent模块的作用和应用场景">33.简述 gevent模块的作用和应用场景。</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/zcqdream/p/6196040.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label115"></a></div><h2 id="twisted框架的使用和应用">34.twisted框架的使用和应用？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/zhiyong-ITNote/p/7360442.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label116"></a></div><h2 id="第三部分-数据库和缓存46题">===============第三部分 数据库和缓存（46题）===============</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label117"></a></div><h2 id="列举常见的关系型数据库和非关系型都有哪些">1. 列举常见的关系型数据库和非关系型都有哪些？</h2>
<pre><code class="hljs awk">  MySQL<span class="hljs-regexp">/SqlServer  MongoDB/</span>Redis
  https:<span class="hljs-regexp">//</span>db-engines.com<span class="hljs-regexp">/en/</span>ranking</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label118"></a></div><h2 id="mysql常见数据库引擎及比较">2. MySQL常见数据库引擎及比较？</h2>
<pre><code class="hljs sql">  MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要<span class="hljs-keyword">update</span>一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) 这类的计算是超快无比的。

  <span class="hljs-keyword">InnoDB</span> 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。

  mysql 数据库引擎: <span class="hljs-keyword">http</span>://www.cnblogs.com/<span class="hljs-number">0201</span>zcr/p/<span class="hljs-number">5296843.</span>html
  MySQL存储引擎－－MyISAM与<span class="hljs-keyword">InnoDB</span>区别: https://segmentfault.com/a/<span class="hljs-number">1190000008227211</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label119"></a></div><h2 id="简述数据三大范式">3. 简述数据三大范式？</h2>
<pre><code class="hljs erlang">  第一范式:确保每列的原子性.
      如果每列(或者每个属性)都是不可再分的最小数据单元(也称为最小的原子单元),则满足第一范式.
      例如:顾客表(姓名、编号、地址、……)其中<span class="hljs-string">"地址"</span>列还可以细分为国家、省、市、区等。
  第二范式:在第一范式的基础上更进一层,目标是确保表中的每列都和主键相关.
      如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式.
      例如:订单表(订单编号、产品编号、定购日期、价格、……)，<span class="hljs-string">"订单编号"</span>为主键，<span class="hljs-string">"产品编号"</span>和主键列没有直接的关系，即<span class="hljs-string">"产品编号"</span>列不依赖于主键列，应删除该列。
  第三范式:在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关.
      如果一个关系满足第二范式,并且除了主键以外的其它列都不依赖于主键列,则满足第三范式.
      为了理解第三范式，需要根据Armstrong公里之一定义传递依赖。假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，依赖A-〉C是传递依赖。
      例如:订单表(订单编号，定购日期，顾客编号，顾客姓名，……)，初看该表没有问题，满足第二范式，每列都和主键列<span class="hljs-string">"订单编号"</span>相关，再细看你会发现<span class="hljs-string">"顾客姓名"</span>和<span class="hljs-string">"顾客编号"</span>相关，<span class="hljs-string">"顾客编号"</span>和<span class="hljs-string">"订单编号"</span>又相关，最后经过传递依赖，<span class="hljs-string">"顾客姓名"</span>也和<span class="hljs-string">"订单编号"</span>相关。为了满足第三范式，应去掉<span class="hljs-string">"顾客姓名"</span>列，放入客户表中。  </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label120"></a></div><h2 id="什么是事务mysql如何支持事务">4. 什么是事务？MySQL如何支持事务？</h2>
<pre><code class="hljs groovy">  数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。
  彻底理解数据库事务: <span class="hljs-string">http:</span><span class="hljs-comment">//www.hollischuang.com/archives/898</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label121"></a></div><h2 id="简述数据库设计中一对多和多对多的应用场景">5. 简述数据库设计中一对多和多对多的应用场景？</h2>
<pre><code class="hljs">  一对一关系示例：
    一个学生对应一个学生档案材料，或者每个人都有唯一的身份证编号。
  一对多关系示例：(下拉单选)
    一个学生只属于一个班，但是一个班级有多名学生。
  多对多关系示例：(下拉多选)
    一个学生可以选择多门课，一门课也有多名学生。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label122"></a></div><h2 id="如何基于数据库实现商城商品计数器">6. 如何基于数据库实现商城商品计数器？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/phpcoder/p/4665850.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label123"></a></div><h2 id="常见sql必备">7. 常见SQL（必备）</h2>
<pre><code class="hljs shell"><span class="hljs-meta">
  #</span><span class="bash"><span class="hljs-comment"># 详见武沛齐博客：https://www.cnblogs.com/wupeiqi/articles/5729934.html</span></span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label124"></a></div><h2 id="简述触发器函数视图存储过程">8. 简述触发器、函数、视图、存储过程？</h2>
<pre><code class="hljs sql">  1）存储过程？
    一组为了完成特定功能的SQL 语句集，经编译后存储在数据库。用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程在创建时即在服务器上进行编译，所以执行起来比单个SQL语句快，因为调用存储过程比直接向服务端发送大量SQL语句在执行速度快。
  对于存储过程，可以接收参数，其参数有三类：
   in          仅用于传入参数用
   out        仅用于返回值用
   inout     既可以传入又可以当作返回值
  2）函数？
    封装一段sql代码，完成一种特定的功能，必须返回结果。其余特性基本跟存储过程相同
  3）函数与存储过程的区别？
    3.1） 函数有且只有一个返回值，而存储过程不能有返回值。
    3.2） 存储过程可以实现很复杂的业务逻辑，函数有很多限制。不能在函数中使用<span class="hljs-keyword">insert</span>,<span class="hljs-keyword">update</span>,<span class="hljs-keyword">delete</span>,<span class="hljs-keyword">create</span>等语句
    <span class="hljs-number">3.3</span>）存储过程可以调用函数。但函数不能调用存储过程。
    <span class="hljs-number">3.4</span>）存储过程一般是作为一个独立的部分来调用。而函数可以作为查询语句的一个部分来调用。
  <span class="hljs-number">4</span>）视图？
    视图是基于 <span class="hljs-keyword">SQL</span> 语句的结果集的可视化虚拟表。
    视图中的字段来自一个或多个数据库中的真实表的字段。视图并不在数据库中以存储数据值集形式存在，而存在于实际引用的数据库表中，视图的构成可以是单表查询，多表联合查询，分组查询以及计算(表达式)查询等。行和列数据在引用视图时动态生成
  <span class="hljs-number">5</span>）触发器？
    触发器（<span class="hljs-keyword">TRIGGER</span>）与函数类似，需要声明、执行。但是触发器的执行不是由程序调用，而是由事件来触发从而实现执行。对某个表进行【增/删/改】操作的前后如果希望触发某个特定的行为时，可以使用触发器，触发器用于定制用户对表的行进行【增/删/改】前后的行为</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label125"></a></div><h2 id="mysql索引种类">9. MySQL索引种类</h2>
<pre><code class="hljs ruby">  MySQL目前主要有以下几种索引类型：
  <span class="hljs-number">1</span>.普通索引
  <span class="hljs-number">2</span>.唯一索引
  <span class="hljs-number">3</span>.主键索引
  <span class="hljs-number">4</span>.组合索引
  <span class="hljs-number">5</span>.全文索引
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/luyucheng</span><span class="hljs-regexp">/p/</span><span class="hljs-number">6289714</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label126"></a></div><h2 id="索引在什么情况下遵循最左前缀的规则">10. 索引在什么情况下遵循最左前缀的规则？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/jamesbd/p/4333901.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label127"></a></div><h2 id="主键和外键的区别">11. 主键和外键的区别？</h2>
<pre><code class="hljs">  1.主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。
  2.外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。一个表可以有多个外键。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label128"></a></div><h2 id="mysql常见的函数">12. MySQL常见的函数？</h2>
<pre><code class="hljs awk">
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/sugang_ximi/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">6664748</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label129"></a></div><h2 id="列举-创建索引但是无法命中索引的8种情况">13. 列举 创建索引但是无法命中索引的8种情况。</h2>
<pre><code class="hljs cs">  - like <span class="hljs-string">'%xx'</span>
      <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> name like <span class="hljs-string">'%cn'</span>;
  - 使用函数
      <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">name</span>) </span>= <span class="hljs-string">'wupeiqi'</span>;
  - or
      <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> nid = <span class="hljs-number">1</span> or email = <span class="hljs-string">'seven@live.com'</span>;
      特别的：当or条件中有未建立索引的列才失效，以下会走索引
              <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> nid = <span class="hljs-number">1</span> or name = <span class="hljs-string">'seven'</span>;
              <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> nid = <span class="hljs-number">1</span> or email = <span class="hljs-string">'seven@live.com'</span> and name = <span class="hljs-string">'alex'</span>
  - 类型不一致
      如果列是字符串类型，传入条件是必须用引号引起来，不然...
      <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> name = <span class="hljs-number">999</span>;
  - !=
      <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> name != <span class="hljs-string">'alex'</span>
      特别的：如果是主键，则还是会走索引
          <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> nid != <span class="hljs-number">123</span>
  - &gt;
      <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> name &gt; <span class="hljs-string">'alex'</span>
      特别的：如果是主键或索引是整数类型，则还是会走索引
          <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> nid &gt; <span class="hljs-number">123</span>
          <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 <span class="hljs-keyword">where</span> num &gt; <span class="hljs-number">123</span>
  - order <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">select</span> email <span class="hljs-keyword">from</span> tb1 order <span class="hljs-keyword">by</span> name desc;
      当根据索引排序时候，选择的映射如果不是索引，则不走索引
      特别的：如果对主键排序，则还是走索引：
          <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb1 order <span class="hljs-keyword">by</span> nid desc;

  https:<span class="hljs-comment">//www.cnblogs.com/iyouyue/p/9004018.html#_label34</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label130"></a></div><h2 id="如何开启慢日志查询">14. 如何开启慢日志查询？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.jianshu.com/p/9f9c9326f8f4</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label131"></a></div><h2 id="数据库导入导出命令结构数据">15. 数据库导入导出命令（结构+数据）？</h2>
<pre><code class="hljs r">  - 导出现有数据库数据：
          mysqldump -u用户名 -p密码 数据库名称 &gt;导出文件路径         <span class="hljs-comment"># 结构+数据</span>
          mysqldump -u用户名 -p密码 -d 数据库名称 &gt;导出文件路径     <span class="hljs-comment"># 结构 </span>
  - 导入现有数据库数据：
          mysqldump -uroot -p密码 数据库名称 &lt; 文件路径</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label132"></a></div><h2 id="数据库优化方案">16. 数据库优化方案？</h2>
<pre><code class="hljs vbnet">  <span class="hljs-number">1.</span> 避免全表扫描，首先应考虑在 <span class="hljs-keyword">where</span> 及 orderby 涉及的列上建立索引。
  <span class="hljs-number">2.</span> 避免在 <span class="hljs-keyword">where</span> 子句中对字段进行 null 值判断，导致引擎放弃使用索引而进行全表扫描 
  <span class="hljs-number">3.</span> 避免在 <span class="hljs-keyword">where</span> 子句中使用 != 或&gt;操作符，引擎将放弃使用索引而进行全表扫描。
  <span class="hljs-number">4.</span> 避免在 <span class="hljs-keyword">where</span> 子句中使用<span class="hljs-keyword">or</span> 来连接条件
  <span class="hljs-number">5.</span> 慎用<span class="hljs-keyword">in</span> 和 <span class="hljs-keyword">not</span>， 可以用 exists 代替 <span class="hljs-keyword">in</span>
  <span class="hljs-number">6.</span> 慎用 <span class="hljs-keyword">like</span> <span class="hljs-comment">'XXX%'，要提高效率，可以全文检索。</span>
  <span class="hljs-number">7.</span> 应尽量避免在 <span class="hljs-keyword">where</span> 子句中对字段进行表达式操作，如：
  <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num/<span class="hljs-number">2</span>=<span class="hljs-number">100</span>
  应改为<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> num=<span class="hljs-number">100</span>*<span class="hljs-number">2</span>
  <span class="hljs-number">8.</span> 避免在<span class="hljs-keyword">where</span>子句中对字段进行函数操作
  <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> substring(name,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)=<span class="hljs-comment">'abc' </span>
  改为:
  <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-comment">'abc%'</span>
  <span class="hljs-number">9.</span> 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。(索引的最左前缀原则) 
  <span class="hljs-number">10.</span> 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。
  <span class="hljs-number">11.</span> 索引不是越多越好，索引可以提高<span class="hljs-keyword">select</span> 的效率，同时也降低 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。
  <span class="hljs-number">12.</span> 任何地方都不要使用 <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> t ，用具体的字段列表代替“*”
  <span class="hljs-number">13.</span> 避免频繁创建和删除临时表，以减少系统表资源的消耗。
  <span class="hljs-number">14.</span> 在新建临时表时，如果一次性插入数据量很大，那么可以使用 <span class="hljs-keyword">select</span> <span class="hljs-keyword">into</span> 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
  <span class="hljs-number">15.</span> 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
  数据库中的数据在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大
  <span class="hljs-number">16.</span> 读写分离。通过数据库配置设置， mysql复制时，产生了多个数据副本（备库），为减少服务器压力，备库用于处理读操作，主库可同时处理读写。备库的复制是异步的，无法实时同步，读写分离的主要难点也在于备库上的脏数据。通常如果使用备库进行读，一般对数据的实时性要求不能太高。
  <span class="hljs-number">17.</span> 分库、分表。
  分库：当数据库中的表太多，可以考虑将表分到不同的数据库
  分表
    水平分表：将一些列分到另一张表
    垂直分表：将历史信息分到另一张表中，很久之前的记录少有查询
  <span class="hljs-number">18.</span> 利用缓存存储经常被查询的数据。利用redis、memcache</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label133"></a></div><h2 id="char和varchar的区别">17. char和varchar的区别？</h2>
<pre><code class="hljs lua">  区别一，定长和变长
  <span class="hljs-built_in">char</span> 表示定长，长度固定，varchar表示变长，即长度可变。当所插入的字符串超出它们的长度时，视情况来处理，如果是严格模式，则会拒绝插入并提示错误信息，如果是宽松模式，则会截取然后插入。如果插入的字符串长度小于定义长度时，则会以不同的方式来处理，如<span class="hljs-built_in">char</span>（<span class="hljs-number">10</span>），表示存储的是<span class="hljs-number">10</span>个字符，无论你插入的是多少，都是<span class="hljs-number">10</span>个，如果少于<span class="hljs-number">10</span>个，则用空格填满。而varchar（<span class="hljs-number">10</span>），小于<span class="hljs-number">10</span>个的话，则插入多少个字符就存多少个。
  varchar怎么知道所存储字符串的长度呢？实际上，对于varchar字段来说，需要使用一个（如果字符串长度小于<span class="hljs-number">255</span>）或两个字节（长度大于<span class="hljs-number">255</span>）来存储字符串的长度。但是因为他需要有一个prefix来表示他具体bytes数是多少（因为varchar是变长的，没有这个长度值他不知道如何读取数据）。

  区别之二，存储的容量不同
  对 <span class="hljs-built_in">char</span> 来说，最多能存放的字符个数 <span class="hljs-number">255</span>，和编码无关。
  而 varchar 呢，最多能存放 <span class="hljs-number">65532</span> 个字符。VARCHAR 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 <span class="hljs-number">65</span>,<span class="hljs-number">532</span>字节</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label134"></a></div><h2 id="简述mysql的执行计划">18. 简述MySQL的执行计划？</h2>
<pre><code class="hljs ruby">  EXPLAIN命令是查看优化器如何决定执行查询的主要方法。可以帮助我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/clsn</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8087501</span>.html<span class="hljs-comment">#auto_id_20</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label135"></a></div><h2 id="在对name做了唯一索引前提下简述limit-1-作用">19. 在对name做了唯一索引前提下，简述limit 1 作用</h2>
<pre><code class="hljs sql">  <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> = ‘Oldboy-Wupeiqi’
  <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> = ‘Oldboy-Wupeiqi’
  是这样的的，用<span class="hljs-keyword">where</span>条件过滤出符合条件的数据的同时，进行计数，比如<span class="hljs-keyword">limit</span> <span class="hljs-number">1</span>，那么在<span class="hljs-keyword">where</span>过滤出第<span class="hljs-number">1</span>条数据后，他就会直接把结果<span class="hljs-keyword">select</span>出来返回给你，整个过程就结束了。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label136"></a></div><h2 id="w条数据使用limit-offset-分页时为什么越往后翻越慢如何解决">20. 1000w条数据，使用limit offset 分页时，为什么越往后翻越慢？如何解决？</h2>
<pre><code class="hljs sql">  答案一：
      先查主键，在分页。
      <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">in</span> (
          <span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">30</span>
      )
  答案二：
      按照也无需求是否可以设置只让用户看<span class="hljs-number">200</span>页
      
  答案三：
      记录当前页  数据<span class="hljs-keyword">ID</span>最大值和最小值
      在翻页时，根据条件先进行筛选；筛选完毕之后，再根据<span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span> 查询。
      
      <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">22222222</span>) <span class="hljs-keyword">as</span> B <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">0</span>
      
      如果用户自己修改页码，也可能导致慢；此时对<span class="hljs-keyword">url</span>种的页码进行加密（rest framework ）</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label137"></a></div><h2 id="什么是索引合并">21. 什么是索引合并？</h2>
<pre><code class="hljs">  1、索引合并是把几个索引的范围扫描合并成一个索引。
  2、索引合并的时候，会对索引进行并集，交集或者先交集再并集操作，以便合并成一个索引。
  3、这些需要合并的索引只能是一个表的。不能对多表进行索引合并。

  简单的说，索引合并，让一条sql可以使用多个索引。对这些索引取交集，并集，或者先取交集再取并集。从而减少从数据表中取数据的次数，提高查询效率。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label138"></a></div><h2 id="什么是覆盖索引">22. 什么是覆盖索引？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/chenpingzhao/p/4776981.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label139"></a></div><h2 id="简述数据库读写分离">23. 简述数据库读写分离？</h2>
<pre><code class="hljs sql"> 读写分离，基本的原理是让主数据库处理事务性增、改、删操作（<span class="hljs-keyword">INSERT</span>、<span class="hljs-keyword">UPDATE</span>、<span class="hljs-keyword">DELETE</span>），而从数据库处理<span class="hljs-keyword">SELECT</span>查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。
 https://blog.csdn.net/xybelieve1990/article/details/<span class="hljs-number">50830908</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label140"></a></div><h2 id="简述数据库分库分表水平垂直">24. 简述数据库分库分表？（水平、垂直）</h2>
<pre><code class="hljs awk">  见<span class="hljs-number">23</span>问题链接
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/xlgen157387/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">53976153</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label141"></a></div><h2 id="redis和memcached比较">25. redis和memcached比较？</h2>
<pre><code class="hljs sql">  使用redis有哪些好处？　
  (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 
  (2) 支持丰富数据类型，支持string，list，<span class="hljs-keyword">set</span>，sorted <span class="hljs-keyword">set</span>，<span class="hljs-keyword">hash</span>
  (<span class="hljs-number">3</span>) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 
  (<span class="hljs-number">4</span>) 丰富的特性：可用于缓存，消息，按<span class="hljs-keyword">key</span>设置过期时间，过期后将会自动删除

  redis相比memcached有哪些优势？ 　　
  (<span class="hljs-number">1</span>) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 
  (<span class="hljs-number">2</span>) redis的速度比memcached快很多 (<span class="hljs-number">3</span>) redis可以持久化其数据

  Memcache与Redis的区别都有哪些？   
  <span class="hljs-number">1</span>)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 
  <span class="hljs-number">2</span>)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 
  <span class="hljs-number">3</span>)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 

  redis与 memcached相比，redis支持<span class="hljs-keyword">key</span>-<span class="hljs-keyword">value</span>数据类型，同时支持<span class="hljs-keyword">list</span>、<span class="hljs-keyword">set</span>、<span class="hljs-keyword">hash</span>等数据结构的存储。
  redis支持数据的备份，即<span class="hljs-keyword">master</span>-<span class="hljs-keyword">slave</span>模式的数据备份。
  redis支持数据的持久化。
  redis在很多方面支持数据库的特性，可以这样说他就是一个数据库系统，而memcached只是简单地K/V缓存。
  它们在性能方面差别不是很大，读取方面尤其是针对批量读取性能方面memcached占据优势。当然redis也有他的优点，如持久性、支持更多的数据结构。
  所以在选择方面如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。
  如果简单的<span class="hljs-keyword">key</span>/<span class="hljs-keyword">value</span> 存储应该选择memcached。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label142"></a></div><h2 id="redis中数据库默认是多少个db-及作用">26. redis中数据库默认是多少个db 及作用？</h2>
<pre><code class="hljs vbscript">  Redis默认支持<span class="hljs-number">16</span>个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择<span class="hljs-number">0</span>号数据库，不过可以随时使用<span class="hljs-keyword">SELECT</span>命令更换数据库
  Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label143"></a></div><h2 id="python操作redis的模块">27. python操作redis的模块？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/Eva-J/p/5152841.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label144"></a></div><h2 id="如果redis中的某个列表中的数据量非常大如果实现循环显示每一个值">28. 如果redis中的某个列表中的数据量非常大，如果实现循环显示每一个值？</h2>
<pre><code class="hljs python">    通过scan_iter分片取，减少内存压力
    scan_iter(match=<span class="hljs-keyword">None</span>, count=<span class="hljs-keyword">None</span>)增量式迭代获取redis里匹配的的值
    <span class="hljs-comment"># match，匹配指定key</span>
    <span class="hljs-comment"># count，每次分片最少获取个数</span>
        r = redis.Redis(connection_pool=pool)
        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> r.scan_iter(match=<span class="hljs-string">'PREFIX_*'</span>, count=<span class="hljs-number">100000</span>):
            print(key)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label145"></a></div><h2 id="redis如何实现主从复制以及数据同步机制">29. redis如何实现主从复制？以及数据同步机制？</h2>
<pre><code class="hljs awk">
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zhangguanghui002/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">78524533</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label146"></a></div><h2 id="redis中的sentinel的作用">30. redis中的sentinel的作用？</h2>
<pre><code class="hljs groovy">    帮助我们自动在主从之间进行切换
    检测主从中 主是否挂掉，且超过一半的sentinel检测到挂了之后才进行进行切换。
    如果主修复好了，再次启动时候，会变成从。

    启动主<span class="hljs-string">redis:</span>
    redis-server <span class="hljs-regexp">/etc/</span>redis<span class="hljs-number">-6379.</span>conf  启动主redis
    redis-server <span class="hljs-regexp">/etc/</span>redis<span class="hljs-number">-6380.</span>conf  启动从redis
        
    在linux中：
        找到 <span class="hljs-regexp">/etc/</span>redis-sentinel<span class="hljs-number">-8001.</span>conf  配置文件，在内部：
            - 哨兵的端口 port = <span class="hljs-number">8001</span>
            - 主redis的IP，哨兵个数的一半/<span class="hljs-number">1</span>
        
        找到 <span class="hljs-regexp">/etc/</span>redis-sentinel<span class="hljs-number">-8002.</span>conf  配置文件，在内部：
            - 哨兵的端口 port = <span class="hljs-number">8002</span>
            - 主redis的IP, <span class="hljs-number">1</span> 
    
        启动两个哨兵      </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label147"></a></div><h2 id="如何实现redis集群">31. 如何实现redis集群？</h2>
<pre><code class="hljs css"> <span class="hljs-selector-tag">redis</span>集群、分片、分布式<span class="hljs-selector-tag">redis</span>
    <span class="hljs-selector-tag">redis-py-cluster</span>
    集群方案：
        <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">redis</span> <span class="hljs-selector-tag">cluster</span> 官方提供的集群方案。
        <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">codis</span>，豌豆荚技术团队。
        <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">tweproxy</span>，<span class="hljs-selector-tag">Twiter</span>技术团队。
    <span class="hljs-selector-tag">redis</span> <span class="hljs-selector-tag">cluster</span>的原理？
        <span class="hljs-selector-tag">-</span> 基于分片来完成。
        <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">redis</span>将所有能放置数据的地方创建了 16384 个哈希槽。
        <span class="hljs-selector-tag">-</span> 如果设置集群的话，就可以为每个实例分配哈希槽：
            <span class="hljs-selector-tag">-</span> 192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.20</span>【0<span class="hljs-selector-tag">-5000</span>】
            <span class="hljs-selector-tag">-</span> 192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.21</span>【5001<span class="hljs-selector-tag">-10000</span>】
            <span class="hljs-selector-tag">-</span> 192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.22</span>【10001<span class="hljs-selector-tag">-16384</span>】
        <span class="hljs-selector-tag">-</span> 以后想要在<span class="hljs-selector-tag">redis</span>中写值时，
            <span class="hljs-selector-tag">set</span> <span class="hljs-selector-tag">k1</span> 123 
          将<span class="hljs-selector-tag">k1</span>通过<span class="hljs-selector-tag">crc16</span>的算法，将<span class="hljs-selector-tag">k1</span>转换成一个数字。然后再将该数字和16384求余，如果得到的余数 3000，那么就将该值写入到 192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.20</span> 实例中。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label148"></a></div><h2 id="redis中默认有多少个哈希槽">32. redis中默认有多少个哈希槽？</h2>
<pre><code class="hljs">
  16384</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label149"></a></div><h2 id="简述redis的有哪几种持久化策略及比较">33. 简述redis的有哪几种持久化策略及比较？</h2>
<pre><code class="hljs">    RDB：每隔一段时间对redis进行一次持久化。
         - 缺点：数据不完整
         - 优点：速度快
    AOF：把所有命令保存起来，如果想到重新生成到redis，那么就要把命令重新执行一次。
         - 缺点：速度慢，文件比较大
         - 优点：数据完整</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label150"></a></div><h2 id="列举redis支持的过期策略数据淘汰策略">34. 列举redis支持的过期策略(数据淘汰策略)。</h2>
<pre><code class="hljs css">  <span class="hljs-selector-tag">voltile-lru</span>：    从已设置过期时间的数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.expires</span>）中挑选最近频率最少数据淘汰
  <span class="hljs-selector-tag">volatile-ttl</span>：   从已设置过期时间的数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.expires</span>）中挑选将要过期的数据淘汰
  <span class="hljs-selector-tag">volatile-random</span>：从已设置过期时间的数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.expires</span>）中任意选择数据淘汰

  
  <span class="hljs-selector-tag">allkeys-lru</span>：       从数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.dict</span>）中挑选最近最少使用的数据淘汰
  <span class="hljs-selector-tag">allkeys-random</span>：    从数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.dict</span>）中任意选择数据淘汰
  <span class="hljs-selector-tag">no-enviction</span>（驱逐）：禁止驱逐数据</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label151"></a></div><h2 id="mysql-里有-2000w-数据redis-中只存-20w-的数据如何保证-redis-中都是热点数据">35. MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中都是热点数据？</h2>
<pre><code class="hljs css">  相关知识：<span class="hljs-selector-tag">redis</span> 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。<span class="hljs-selector-tag">redis</span> 提供 6种数据淘汰策略：

  <span class="hljs-selector-tag">volatile-lru</span>：从已设置过期时间的数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.expires</span>）中挑选最近最少使用的数据淘汰
  <span class="hljs-selector-tag">volatile-ttl</span>：从已设置过期时间的数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.expires</span>）中挑选将要过期的数据淘汰
  <span class="hljs-selector-tag">volatile-random</span>：从已设置过期时间的数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.expires</span>）中任意选择数据淘汰
  <span class="hljs-selector-tag">allkeys-lru</span>：从数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.dict</span>）中挑选最近最少使用的数据淘汰
  <span class="hljs-selector-tag">allkeys-random</span>：从数据集（<span class="hljs-selector-tag">server</span><span class="hljs-selector-class">.db</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.dict</span>）中任意选择数据淘汰
  <span class="hljs-selector-tag">no-enviction</span>（驱逐）：禁止驱逐数据</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label152"></a></div><h2 id="写代码基于redis的列表实现-先进先出后进先出队列优先级队列">36. 写代码，基于redis的列表实现 先进先出、后进先出队列、优先级队列。</h2>
<pre><code class="hljs python">
  <span class="hljs-keyword">from</span> scrapy.utils.reqser <span class="hljs-keyword">import</span> request_to_dict, request_from_dict

  <span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> picklecompat


  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span><span class="hljs-params">(object)</span>:</span>
      <span class="hljs-string">"""Per-spider base queue class"""</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, server, spider, key, serializer=None)</span>:</span>
          <span class="hljs-string">"""Initialize per-spider redis queue.

          Parameters
          ----------
          server : StrictRedis
              Redis client instance.
          spider : Spider
              Scrapy spider instance.
          key: str
              Redis key where to put and get messages.
          serializer : object
              Serializer object with ``loads`` and ``dumps`` methods.

          """</span>
          <span class="hljs-keyword">if</span> serializer <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
              <span class="hljs-comment"># Backward compatibility.</span>
              <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> deprecate pickle.</span>
              serializer = picklecompat
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(serializer, <span class="hljs-string">'loads'</span>):
              <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">"serializer does not implement 'loads' function: %r"</span>
                              % serializer)
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(serializer, <span class="hljs-string">'dumps'</span>):
              <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">"serializer '%s' does not implement 'dumps' function: %r"</span>
                              % serializer)

          self.server = server
          self.spider = spider
          self.key = key % {<span class="hljs-string">'spider'</span>: spider.name}
          self.serializer = serializer

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_encode_request</span><span class="hljs-params">(self, request)</span>:</span>
          <span class="hljs-string">"""Encode a request object"""</span>
          obj = request_to_dict(request, self.spider)
          <span class="hljs-keyword">return</span> self.serializer.dumps(obj)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_decode_request</span><span class="hljs-params">(self, encoded_request)</span>:</span>
          <span class="hljs-string">"""Decode an request previously encoded"""</span>
          obj = self.serializer.loads(encoded_request)
          <span class="hljs-keyword">return</span> request_from_dict(obj, self.spider)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span>
          <span class="hljs-string">"""Return the length of the queue"""</span>
          <span class="hljs-keyword">raise</span> NotImplementedError

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, request)</span>:</span>
          <span class="hljs-string">"""Push a request"""</span>
          <span class="hljs-keyword">raise</span> NotImplementedError

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self, timeout=<span class="hljs-number">0</span>)</span>:</span>
          <span class="hljs-string">"""Pop a request"""</span>
          <span class="hljs-keyword">raise</span> NotImplementedError

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span><span class="hljs-params">(self)</span>:</span>
          <span class="hljs-string">"""Clear queue/stack"""</span>
          self.server.delete(self.key)


  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FifoQueue</span><span class="hljs-params">(Base)</span>:</span>
      <span class="hljs-string">"""Per-spider FIFO queue"""</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span>
          <span class="hljs-string">"""Return the length of the queue"""</span>
          <span class="hljs-keyword">return</span> self.server.llen(self.key)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, request)</span>:</span>
          <span class="hljs-string">"""Push a request"""</span>
          self.server.lpush(self.key, self._encode_request(request))

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self, timeout=<span class="hljs-number">0</span>)</span>:</span>
          <span class="hljs-string">"""Pop a request"""</span>
          <span class="hljs-keyword">if</span> timeout &gt; <span class="hljs-number">0</span>:
              data = self.server.brpop(self.key, timeout)
              <span class="hljs-keyword">if</span> isinstance(data, tuple):
                  data = data[<span class="hljs-number">1</span>]
          <span class="hljs-keyword">else</span>:
              data = self.server.rpop(self.key)
          <span class="hljs-keyword">if</span> data:
              <span class="hljs-keyword">return</span> self._decode_request(data)


  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">(Base)</span>:</span>
      <span class="hljs-string">"""Per-spider priority queue abstraction using redis' sorted set"""</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span>
          <span class="hljs-string">"""Return the length of the queue"""</span>
          <span class="hljs-keyword">return</span> self.server.zcard(self.key)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, request)</span>:</span>
          <span class="hljs-string">"""Push a request"""</span>
          data = self._encode_request(request)
          score = -request.priority
          <span class="hljs-comment"># We don't use zadd method as the order of arguments change depending on</span>
          <span class="hljs-comment"># whether the class is Redis or StrictRedis, and the option of using</span>
          <span class="hljs-comment"># kwargs only accepts strings, not bytes.</span>
          self.server.execute_command(<span class="hljs-string">'ZADD'</span>, self.key, score, data)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self, timeout=<span class="hljs-number">0</span>)</span>:</span>
          <span class="hljs-string">"""
          Pop a request
          timeout not support in this queue class
          """</span>
          <span class="hljs-comment"># use atomic range/remove using multi/exec</span>
          pipe = self.server.pipeline()
          pipe.multi()
          pipe.zrange(self.key, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>).zremrangebyrank(self.key, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
          results, count = pipe.execute()
          <span class="hljs-keyword">if</span> results:
              <span class="hljs-keyword">return</span> self._decode_request(results[<span class="hljs-number">0</span>])


  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifoQueue</span><span class="hljs-params">(Base)</span>:</span>
      <span class="hljs-string">"""Per-spider LIFO queue."""</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span>
          <span class="hljs-string">"""Return the length of the stack"""</span>
          <span class="hljs-keyword">return</span> self.server.llen(self.key)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, request)</span>:</span>
          <span class="hljs-string">"""Push a request"""</span>
          self.server.lpush(self.key, self._encode_request(request))

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self, timeout=<span class="hljs-number">0</span>)</span>:</span>
          <span class="hljs-string">"""Pop a request"""</span>
          <span class="hljs-keyword">if</span> timeout &gt; <span class="hljs-number">0</span>:
              data = self.server.blpop(self.key, timeout)
              <span class="hljs-keyword">if</span> isinstance(data, tuple):
                  data = data[<span class="hljs-number">1</span>]
          <span class="hljs-keyword">else</span>:
              data = self.server.lpop(self.key)

          <span class="hljs-keyword">if</span> data:
              <span class="hljs-keyword">return</span> self._decode_request(data)


  <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> Deprecate the use of these names.</span>
  SpiderQueue = FifoQueue
  SpiderStack = LifoQueue
  SpiderPriorityQueue = PriorityQueue</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label153"></a></div><h2 id="如何基于redis实现消息队列">37. 如何基于redis实现消息队列？</h2>
<pre><code class="hljs groovy">  不要使用redis去做消息队列，这不是redis的设计目标。
  但实在太多人使用redis去做去消息队列，redis的作者看不下去，另外基于redis的核心代码，另外实现了一个消息队列disque：<span class="hljs-string">https:</span><span class="hljs-comment">//github.com/antirez/disque</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label154"></a></div><h2 id="如何基于redis实现发布和订阅以及发布订阅和消息队列的区别">38. 如何基于redis实现发布和订阅？以及发布订阅和消息队列的区别？</h2>
<pre><code class="hljs python">  发布者：
      <span class="hljs-keyword">import</span> redis

      conn = redis.Redis(host=<span class="hljs-string">'127.0.0.1'</span>,port=<span class="hljs-number">6379</span>)
      conn.publish(<span class="hljs-string">'104.9MH'</span>, <span class="hljs-string">"hahaha"</span>)
  订阅者：
      <span class="hljs-keyword">import</span> redis

      conn = redis.Redis(host=<span class="hljs-string">'127.0.0.1'</span>,port=<span class="hljs-number">6379</span>)
      pub = conn.pubsub()
      pub.subscribe(<span class="hljs-string">'104.9MH'</span>)

      <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
          msg= pub.parse_response()
          print(msg)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label155"></a></div><h2 id="什么是codis及作用">39. 什么是codis及作用？</h2>
<pre><code class="hljs javascript">
  Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis <span class="hljs-built_in">Proxy</span> 和连接原生的 Redis Server 没有明显的区别 (不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务.</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label156"></a></div><h2 id="什么是twemproxy及作用">40. 什么是twemproxy及作用？</h2>
<pre><code class="hljs sql">
  是 Twtter 开源的一个 Redis 和 Memcache 代理服务器，主要用于管理 Redis 和 Memcached 集群，减少与<span class="hljs-keyword">Cache</span> 服务器直接连接的数量。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label157"></a></div><h2 id="写代码实现redis事务操作">41. 写代码实现redis事务操作。</h2>
<pre><code class="hljs python">  <span class="hljs-keyword">import</span> redis

  pool = redis.ConnectionPool(host=<span class="hljs-string">'10.211.55.4'</span>, port=<span class="hljs-number">6379</span>)

  conn = redis.Redis(connection_pool=pool)

  <span class="hljs-comment"># pipe = r.pipeline(transaction=False)</span>
  pipe = conn.pipeline(transaction=<span class="hljs-keyword">True</span>)
  <span class="hljs-comment"># 开始事务</span>
  pipe.multi()

  pipe.set(<span class="hljs-string">'name'</span>, <span class="hljs-string">'bendere'</span>)
  pipe.set(<span class="hljs-string">'role'</span>, <span class="hljs-string">'sb'</span>)

  <span class="hljs-comment"># 提交</span>
  pipe.execute()
  
  注意：咨询是否当前分布式redis是否支持事务</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label158"></a></div><h2 id="redis中的watch的命令的作用">42. redis中的watch的命令的作用？</h2>
<pre><code class="hljs sql">  在Redis的事务中，WATCH命令可用于提供CAS(<span class="hljs-keyword">check</span>-<span class="hljs-keyword">and</span>-<span class="hljs-keyword">set</span>)功能。假设我们通过WATCH命令在事务执行之前监控了多个<span class="hljs-keyword">Keys</span>，倘若在WATCH之后有任何<span class="hljs-keyword">Key</span>的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回<span class="hljs-literal">Null</span> multi-<span class="hljs-keyword">bulk</span>应答以通知调用者事务执行失败。
  
  面试题：你如何控制剩余的数量不会出问题？
      - 通过redis的watch实现
          <span class="hljs-keyword">import</span> redis
          <span class="hljs-keyword">conn</span> = redis.Redis(host=<span class="hljs-string">'127.0.0.1'</span>,port=<span class="hljs-number">6379</span>)

          # conn.set(<span class="hljs-string">'count'</span>,<span class="hljs-number">1000</span>)
          val = conn.get(<span class="hljs-string">'count'</span>)
          print(val)

          <span class="hljs-keyword">with</span> conn.pipeline(<span class="hljs-keyword">transaction</span>=<span class="hljs-literal">True</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">pipe</span>:

              # 先监视，自己的值没有被修改过
              conn.watch(<span class="hljs-string">'count'</span>)

              # 事务开始
              pipe.multi()
              old_count = conn.get(<span class="hljs-string">'count'</span>)
              <span class="hljs-keyword">count</span> = <span class="hljs-built_in">int</span>(old_count)
              print(<span class="hljs-string">'现在剩余的商品有:%s'</span>,<span class="hljs-keyword">count</span>)
              <span class="hljs-keyword">input</span>(<span class="hljs-string">"问媳妇让不让买？"</span>)
              pipe.set(<span class="hljs-string">'count'</span>, <span class="hljs-keyword">count</span> - <span class="hljs-number">1</span>)

              # 执行，把所有命令一次性推送过去
              pipe.execute()
      - 数据库的锁 </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label159"></a></div><h2 id="基于redis如何实现商城商品数量计数器">43. 基于redis如何实现商城商品数量计数器？</h2>
<pre><code class="hljs javascript">  Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（<span class="hljs-built_in">Set</span>）和有序集合（Sorted <span class="hljs-built_in">Set</span>）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的<span class="hljs-number">10</span>个用户–我们
  称之为“user_scores”，我们只需要像下面一样执行即可：
  当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：
  ZRANGE user_scores <span class="hljs-number">0</span> <span class="hljs-number">10</span> WITHSCORES
  Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label160"></a></div><h2 id="简述redis分布式锁和redlock的实现机制">44. 简述redis分布式锁和redlock的实现机制。</h2>
<pre><code class="hljs javascript">  在不同进程需要互斥地访问共享资源时，分布式锁是一种非常有用的技术手段。 有很多三方库和文章描述如何用Redis实现一个分布式锁管理器，但是这些库实现的方式差别很大，而且很多简单的实现其实只需采用稍微增加一点复杂的设计就可以获得更好的可靠性。 这篇文章的目的就是尝试提出一种官方权威的用Redis实现分布式锁管理器的算法，我们把这个算法称为RedLock。
  https:<span class="hljs-comment">//www.cnblogs.com/ironPhoenix/p/6048467.html</span>
  https:<span class="hljs-comment">//blog.csdn.net/junli_chen/article/details/79228282</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label161"></a></div><h2 id="什么是一致性哈希python中是否有相应模块">45. 什么是一致性哈希？Python中是否有相应模块？</h2>
<pre><code class="hljs lua">
  Python模块<span class="hljs-comment">--hash_ring，即Python中的一致性hash</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label162"></a></div><h2 id="如何高效的找到redis中所有以aaa开头的key">46. 如何高效的找到redis中所有以aaa开头的key？</h2>
<pre><code class="hljs less">  <span class="hljs-selector-tag">redis</span> 有一个<span class="hljs-selector-tag">keys</span>命令。
  语法：<span class="hljs-selector-tag">KEYS</span> <span class="hljs-selector-tag">pattern</span>
  说明：返回与指定模式相匹配的所用的<span class="hljs-selector-tag">keys</span>。
  该命令所支持的匹配模式如下：
  （<span class="hljs-selector-tag">1</span>）?：用于匹配单个字符。例如，<span class="hljs-selector-tag">h</span>?<span class="hljs-selector-tag">llo</span>可以匹配<span class="hljs-selector-tag">hello</span>、<span class="hljs-selector-tag">hallo</span>和<span class="hljs-selector-tag">hxllo</span>等；
  （<span class="hljs-selector-tag">2</span>）*：用于匹配零个或者多个字符。例如，<span class="hljs-selector-tag">h</span>*<span class="hljs-selector-tag">llo</span>可以匹配<span class="hljs-selector-tag">hllo</span>和<span class="hljs-selector-tag">heeeello</span>等；
  （<span class="hljs-selector-tag">3</span>）<span class="hljs-selector-attr">[]</span>：可以用来指定模式的选择区间。例如<span class="hljs-selector-tag">h</span><span class="hljs-selector-attr">[ae]</span><span class="hljs-selector-tag">llo</span>可以匹配<span class="hljs-selector-tag">hello</span>和<span class="hljs-selector-tag">hallo</span>，但是不能匹配<span class="hljs-selector-tag">hillo</span>。
  同时，可以使用“/”符号来转义特殊的字符</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label163"></a></div><h2 id="第四部分-前端框架和其他155题">==============第四部分 前端、框架和其他（155题）===============</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label164"></a></div><h2 id="谈谈你对http协议的认识">1. 谈谈你对http协议的认识。</h2>
<pre><code class="hljs lua">  流程：
      <span class="hljs-number">1.</span>域名解析
      域名解析检查顺序为：浏览器自身DNS缓存<span class="hljs-comment">---》OS自身的DNS缓存--》读取host文件--》本地域名服务器--》权限域名服务器--》根域名服务器。如果有且没有过期，则结束本次域名解析。域名解析成功之后，进行后续操作</span>
      <span class="hljs-number">2.</span>tcp3次握手建立连接
      <span class="hljs-number">3.</span>建立连接后，发起http请求
      <span class="hljs-number">4.</span>服务器端响应http请求，浏览器得到到http请求的内容
      <span class="hljs-number">5.</span>浏览器解析html代码，并请求html代码中的资源
      <span class="hljs-number">6.</span>浏览器对页面进行渲染，展现在用户面前</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label165"></a></div><h2 id="谈谈你对websocket协议的认识">2. 谈谈你对websocket协议的认识。</h2>
<pre><code class="hljs ruby">  WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。
  特点:
  事件驱动
  异步
  使用ws或者wss协议的客户端socket

  能够实现真正意义上的推送功能

  缺点：
  少部分浏览器不支持，浏览器支持的程度与方式有区别。
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/best</span><span class="hljs-regexp">/p/</span><span class="hljs-number">5695570</span>.html<span class="hljs-comment">#_label1</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label166"></a></div><h2 id="什么是magic-string">3. 什么是magic string ？</h2>
<pre><code class="hljs">  魔法
  字符串</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label167"></a></div><h2 id="如何创建响应式布局">4. 如何创建响应式布局？</h2>
<pre><code class="hljs css">  @<span class="hljs-keyword">media</span> (min-width: <span class="hljs-number">768px</span>){
      <span class="hljs-selector-class">.pg-header</span>{
          <span class="hljs-attribute">background-color</span>: green;
      }
  }
  @<span class="hljs-keyword">media</span> (min-width: <span class="hljs-number">992px</span>){
      <span class="hljs-selector-class">.pg-header</span>{
          <span class="hljs-attribute">background-color</span>: pink;
      }
  }</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label168"></a></div><h2 id="你曾经使用过哪些前端框架">5. 你曾经使用过哪些前端框架？</h2>
<pre><code class="hljs">  跳
  过</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label169"></a></div><h2 id="什么是ajax请求并使用jquery和xmlhttprequest对象实现一个ajax请求">6. 什么是ajax请求？并使用jQuery和XMLHttpRequest对象实现一个ajax请求。</h2>
<pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JqSendRequest</span>(<span class="hljs-params"></span>)</span>{
            $.ajax({
                <span class="hljs-attr">url</span>: <span class="hljs-string">"http://c2.com:8000/test/"</span>,
                <span class="hljs-attr">type</span>: <span class="hljs-string">'GET'</span>,
                <span class="hljs-attr">dataType</span>: <span class="hljs-string">'text'</span>,
                <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, statusText, xmlHttpRequest</span>)</span>{
                    <span class="hljs-built_in">console</span>.log(data);
                }
            })
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    http://www.cnblogs.com/wupeiqi/articles/5703697.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label170"></a></div><h2 id="如何在前端实现轮询">7. 如何在前端实现轮询？</h2>
<pre><code class="hljs ruby">  轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。
  优点：后端程序编写比较容易。 缺点：请求中有大半是无用，浪费带宽和服务器资源。 实例：适于小型应用。
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/zhaowinter</span><span class="hljs-regexp">/p/</span><span class="hljs-number">5332681</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label171"></a></div><h2 id="如何在前端实现长轮询">8. 如何在前端实现长轮询？</h2>
<pre><code class="hljs">  客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。
  优点：在无消息的情况下不会频繁的请求，耗费资小。 
  缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet异步的ashx，
  实例：WebQQ、Hi网页版、Facebook IM。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label172"></a></div><h2 id="vuex的作用">9. vuex的作用？</h2>
<pre><code class="hljs awk">  在使用库或框架时，需要注意一个「适用性」的问题。
  Vuex 或者说实现了 Flux 思想的库，解决了几个问题：

  组件之间的数据通信
  使用单向数据流的方式进行数据的中心化管理
  为什么要解决这样的问题呢？其实是因为当程序逻辑过于复杂的时候，非中心化的数据管理会让整个 app 的逻辑非常混乱。
  举一个不使用中心化的数据管理机制的具体例子：

  一个 app ，有四个 tab，每个 tab 都需要读取用户的资料。如果数据在每个 tab 的控制器里（或者说组件里）都存了一份，那么在用户手动更新了用户资料之后，就需要在每一个 tab 里都更新一遍用户资料，才能保证用户看到的永远是最新的资料。
  如你问题里所说，我每进一个 tab 的时候重新请求一下不就好了吗？
  这样的解决方案不是不可以，但弊端也非常明显：

  <span class="hljs-number">1</span>) 对于服务器端来说，频繁的请求是非常占用资源的，如果你的 app 用户足够多，那么每多出一个请求，对公司来说，都是一大笔钱。如果数据存在了 store 中，并且所有的 tab 都读取同一份数据，在用户更新资料时，在前端更新了 store 中的数据，是不是在切换 tab 时就减少了四个请求呢？
  <span class="hljs-number">2</span>) 对于前端开发者来说，如果你的项目足够复杂，团队的规模也不仅是一个人，那么前端代码就会因为数据分散管理而产生非常严重的性能和稳定性的隐患（比如你的同事觉得进入模块就刷新用户资料太慢了，手贱把刷新的代码删了，你又没发现）。
  https:<span class="hljs-regexp">//</span>segmentfault.com<span class="hljs-regexp">/q/</span><span class="hljs-number">1010000011402824</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label173"></a></div><h2 id="vue中的路由的拦截器的作用">10. Vue中的路由的拦截器的作用？</h2>
<pre><code class="hljs vbscript">
  vue-resource的interceptors拦截器的作用正是解决此需求的妙方。在每次http的请求响应之后，如果设置了拦截器如下，会优先执行拦截器函数，获取响应体，然后才会决定是否把<span class="hljs-built_in">response</span>返回给<span class="hljs-keyword">then</span>进行接收</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label174"></a></div><h2 id="axios的作用">11. axios的作用？</h2>
<pre><code class="hljs awk">
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_27626333/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">76254888</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label175"></a></div><h2 id="列举vue的常见指令">12. 列举Vue的常见指令。</h2>
<pre><code class="hljs groovy">  <span class="hljs-number">1</span>、v-<span class="hljs-keyword">if</span>指令:判断指令，根据表达式值得真假来插入或删除相应的值。
  <span class="hljs-number">2</span>、v-show指令:条件渲染指令，无论返回的布尔值是<span class="hljs-literal">true</span>还是<span class="hljs-literal">false</span>，元素都会存在在html中，只是<span class="hljs-literal">false</span>的元素会隐藏在html中，并不会删除.
  <span class="hljs-number">3</span>、v-<span class="hljs-keyword">else</span>指令:配合v-<span class="hljs-keyword">if</span>或v-<span class="hljs-keyword">else</span>使用。
  <span class="hljs-number">4</span>、v-<span class="hljs-keyword">for</span>指令:循环指令，相当于遍历。
  <span class="hljs-number">5</span>、v-<span class="hljs-string">bind:</span>给DOM绑定元素属性。
  <span class="hljs-number">6</span>、v-on指令:监听DOM事件。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label176"></a></div><h2 id="简述jsonp及实现原理">13. 简述JSONP及实现原理？</h2>
<pre><code class="hljs ruby">  JSONP是json用来跨域的一个东西。原理是通过script标签的跨域特性来绕过同源策略。（创建一个回调函数，然后在远程服务上调用这个函数并且将json数据形式作为参数传递，完成回调）。
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/huchong</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8469053</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label177"></a></div><h2 id="是什么cors">14. 是什么CORS ？</h2>
<pre><code class="hljs ruby">  跨域资源共享（CORS，Cross-Origin Resource Sharing），其本质是设置响应头，使得浏览器允许跨域请求。
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/huchong</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8469063</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label178"></a></div><h2 id="列举http请求中常见的请求方式">15. 列举Http请求中常见的请求方式？</h2>
<pre><code class="hljs vbscript">  请求方法有<span class="hljs-number">8</span>种，分别为：
    <span class="hljs-keyword">GET</span>：请求获取由 <span class="hljs-built_in">Request</span>-URI 所标识的资源。
    POST：在 <span class="hljs-built_in">Request</span>-URI 所标识的资源后附加新的数据。
    HEAD：请求获取由 <span class="hljs-built_in">Request</span>-URI 所标识的资源的响应消息报头。
    OPTIONS：请求查询服务器的性能，或查询与资源相关的选项和需求。
    PUT：请求服务器存储一个资源，并用 <span class="hljs-built_in">Request</span>-URI作为其标识。
    DELETE：请求服务器删除由 <span class="hljs-built_in">Request</span>-URI所标识的资源。
    TRACE：请求服务器回送收到的请求信息，主要用语测试或诊断。
    CONNECT：HTTP/<span class="hljs-number">1.1</span>协议中预留给能够将连接改为管道方式的代理服务器。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label179"></a></div><h2 id="列举http请求中的状态码">16. 列举Http请求中的状态码？</h2>
<pre><code class="hljs vbscript">   常见的响应状态码有以下几种，在各种下面分别列几个常见的状态码：
       <span class="hljs-number">1</span>开头（信息）
       <span class="hljs-number">2</span>开头（成功）
           <span class="hljs-number">200</span>（OK）：请求成功
           <span class="hljs-number">202</span>（Accepted）：已接受请求，尚未处理
           <span class="hljs-number">204</span>（No Content）：请求成功，且不需返回内容
       <span class="hljs-number">3</span>开头（重定向）
           <span class="hljs-number">301</span>（Moved Permanently）：被请求的资源已永久移动到新位置
           <span class="hljs-number">301</span>（Moved Temporarily）：被请求的资源已临时移动到新位置
       <span class="hljs-number">4</span>开头（客户端错误）
           <span class="hljs-number">400</span>（Bad <span class="hljs-built_in">Request</span>）：请求的语义或是参数有错
           <span class="hljs-number">403</span>（Forbidden）：服务器拒绝了请求
           <span class="hljs-number">404</span>（<span class="hljs-keyword">Not</span> Found）：未找到请求的资源
       <span class="hljs-number">5</span>开头（服务器错误）
          <span class="hljs-number">500</span>（Internal <span class="hljs-built_in">Server</span> <span class="hljs-keyword">Error</span>）：服务器遇到错误，无法完成请求
          <span class="hljs-number">502</span>（Bad Getway）：网关错误，一般是服务器压力过大导致连接超时       
          <span class="hljs-number">503</span>（Service Unavailable）：服务器宕机</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label180"></a></div><h2 id="列举http请求中常见的请求头">17. 列举Http请求中常见的请求头？</h2>
<pre><code class="hljs yaml"><span class="hljs-attr">  Accept:</span>
  <span class="hljs-string">浏览器端可以接受的媒体类型,通配符</span> <span class="hljs-string">*</span> <span class="hljs-string">代表任意类型</span>
  <span class="hljs-string">Accept-Encoding：</span>
  <span class="hljs-string">浏览器申明自己接收的编码方法,例如：</span> <span class="hljs-attr">Accept-Encoding:</span> <span class="hljs-string">zh-CN,zh;q=0.8</span>
<span class="hljs-attr">  Accept-Language:</span>
  <span class="hljs-string">浏览器申明自己接收的语言,</span>
<span class="hljs-attr">  Connection:</span>
  <span class="hljs-string">如Connection:</span> <span class="hljs-string">keep-alive</span> <span class="hljs-string">当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，</span>
  <span class="hljs-string">如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</span>
  <span class="hljs-string">Referer：</span>
  <span class="hljs-string">当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。</span>
  <span class="hljs-string">User-Agent：</span>
  <span class="hljs-string">告诉HTTP服务器，</span> <span class="hljs-string">客户端使用的操作系统和浏览器的名称和版本.</span>
  <span class="hljs-string">Cookie：</span>
  <span class="hljs-string">Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，</span>
  <span class="hljs-string">当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label181"></a></div><h2 id="看图写结果js略">18. 看图写结果：JS，略</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label182"></a></div><h2 id="看图写结果js略-1">19. 看图写结果：JS，略</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label183"></a></div><h2 id="看图写结果js略-2">20. 看图写结果：JS，略</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label184"></a></div><h2 id="看图写结果js略-3">21. 看图写结果：JS，略</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label185"></a></div><h2 id="看图写结果js略-4">22. 看图写结果：JS，略</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label186"></a></div><h2 id="看图写结果js略-5">23. 看图写结果：JS，略</h2>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label187"></a></div><h2 id="djangoflasktornado框架的比较">24. django、flask、tornado框架的比较？</h2>
<pre><code class="hljs">  d：大而全
  f：微型灵活
  t：异步非阻塞</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label188"></a></div><h2 id="什么是wsgi">25. 什么是wsgi？</h2>
<pre><code class="hljs delphi">  Python Web服务器网关接口（Python Web Server Gateway <span class="hljs-keyword">Interface</span>，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标。
  http:<span class="hljs-comment">//python.jobbole.com/88653/</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label189"></a></div><h2 id="django请求的生命周期">26. django请求的生命周期？</h2>
<pre><code class="hljs perl">  a. wsgi, 创建<span class="hljs-keyword">socket</span>服务端，用于接收用户请求并对请求进行初次封装。
  b. 中间件，对所有请求到来之前，响应之前定制一些操作。
  c. 路由匹配，在url和视图函数对应关系中，根据当前请求url找到相应的函数。
  d. 执行视图函数，业务处理【通过ORM去数据库中获取数据，再去拿到模板，然后将数据和模板进行渲染】
  e. 再经过所有中间件。
  f. 通过wsgi将响应返回给用户。 </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label190"></a></div><h2 id="列举django的内置组件">27. 列举django的内置组件？</h2>
<pre><code class="hljs groovy">
  form<span class="hljs-regexp">/modelform/</span>admin</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label191"></a></div><h2 id="列举django中间件的5个方法以及django中间件的应用场景">28. 列举django中间件的5个方法？以及django中间件的应用场景？</h2>
<pre><code class="hljs vbscript">  中间件中方法？<span class="hljs-number">5</span>个方法,分别是：
      process_request(self,<span class="hljs-built_in">request</span>)
      process_view(self, <span class="hljs-built_in">request</span>, callback, callback_args, callback_kwargs)
      process_template_response(self,<span class="hljs-built_in">request</span>,<span class="hljs-built_in">response</span>)
      process_exception(self, <span class="hljs-built_in">request</span>, exception)
      process_response(self, <span class="hljs-built_in">request</span>, <span class="hljs-built_in">response</span>)
      <span class="hljs-number">1</span> 请求先执行所有中间件的process_request,然后做路由匹配，找到函数不执行。
      <span class="hljs-number">2</span> 再执行所有的process_view,在执行视图函数。
      <span class="hljs-number">3</span> 再执行process_response
      <span class="hljs-number">4</span> 如果程序报错执行process_exception
      <span class="hljs-number">5</span> 如果程序有render方法则执行process_template_response</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label192"></a></div><h2 id="简述什么是fbv和cbv">29. 简述什么是FBV和CBV？</h2>
<pre><code class="hljs ruby">  <span class="hljs-number">1</span> FBV方式请求的过程
  用户发送url请求,Django会依次遍历路由映射表中的所有记录,一旦路由映射表其中的一条匹配成功了,
  就执行视图函数中对应的函数名,这是fbv的执行流程

  <span class="hljs-number">2</span> CBV方式请求的过程
  当服务端使用CBV模式的时候,用户发给服务端的请求包含url和method,这两个信息都是字符串类型

  服务端通过路由映射表匹配成功后会自动去找dispatch方法,然后Django会通过dispatch反射的方式找到类中对应的方法并执行

  类中的方法执行完毕之后,会把客户端想要的数据返回给dispatch方法,由dispatch方法把数据返回经客户端

  把上面的例子中的视图函数修改成如下:
  from django.views import View

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CBV</span>(<span class="hljs-title">View</span>):</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, request, *args, **kwargs)</span></span>:
          print(<span class="hljs-string">"dispatch......"</span>)
          res=<span class="hljs-keyword">super</span>(CBV,<span class="hljs-keyword">self</span>).dispatch(request,*args,**kwargs)
          <span class="hljs-keyword">return</span> res

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,request)</span></span>:
          <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">"cbv.html"</span>)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,request)</span></span>:
          <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"cbv.get"</span>)

  <span class="hljs-number">3</span> FBV和CBV的区别？
      - 没什么区别，因为他们的本质都是函数。CBV的.as_view()返回的view函数，view函数中调用类的dispatch方法，在dispatch方法中通过反射执行get/post/delete/put等方法。
      - CBV比较简洁，GET/POST等业务功能分别放在不同get/post函数中。FBV自己做判断进行区分。

  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/renpingsheng</span><span class="hljs-regexp">/p/</span><span class="hljs-number">7534897</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label193"></a></div><h2 id="django的request对象是在什么时候创建的">30. django的request对象是在什么时候创建的？</h2>
<pre><code class="hljs awk">  当请求一个页面时, Django会建立一个包含请求元数据的 HttpRequest 对象. 当Django 加载对应的视图时, HttpRequest对象将作为视图函数的第一个参数. 每个视图会返回一个HttpResponse对象.
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/mbl114/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">78090773</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label194"></a></div><h2 id="如何给cbv的程序添加装饰器">31. 如何给CBV的程序添加装饰器？</h2>
<pre><code class="hljs python">  - 装饰器
  <span class="hljs-keyword">from</span> django.views <span class="hljs-keyword">import</span> View
  <span class="hljs-keyword">from</span> django.utils.decorators <span class="hljs-keyword">import</span> method_decorator

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">auth</span><span class="hljs-params">(func)</span>:</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">(*args,**kwargs)</span>:</span>
          <span class="hljs-keyword">return</span> func(*args,**kwargs)
      <span class="hljs-keyword">return</span> inner

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserView</span><span class="hljs-params">(View)</span>:</span>
<span class="hljs-meta">      @method_decorator(auth)</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self,request,*args,**kwargs)</span>:</span>
          <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">'...'</span>)

  - csrf的装饰器要加到dispath
      <span class="hljs-keyword">from</span> django.views <span class="hljs-keyword">import</span> View
      <span class="hljs-keyword">from</span> django.utils.decorators <span class="hljs-keyword">import</span> method_decorator
      <span class="hljs-keyword">from</span> django.views.decorators.csrf <span class="hljs-keyword">import</span> csrf_exempt,csrf_protect


      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserView</span><span class="hljs-params">(View)</span>:</span>
<span class="hljs-meta">          @method_decorator(csrf_exempt)</span>
          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(self, request, *args, **kwargs)</span>:</span>
              <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">'...'</span>)
          
  或
      <span class="hljs-keyword">from</span> django.views <span class="hljs-keyword">import</span> View
      <span class="hljs-keyword">from</span> django.utils.decorators <span class="hljs-keyword">import</span> method_decorator
      <span class="hljs-keyword">from</span> django.views.decorators.csrf <span class="hljs-keyword">import</span> csrf_exempt,csrf_protect

<span class="hljs-meta">      @method_decorator(csrf_exempt,name='dispatch')</span>
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserView</span><span class="hljs-params">(View)</span>:</span>
          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(self, request, *args, **kwargs)</span>:</span>
              <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">'...'</span>)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label195"></a></div><h2 id="列举django-orm-中所有的方法queryset对象的所有方法">32. 列举django orm 中所有的方法（QuerySet对象的所有方法）</h2>
<pre><code class="hljs less"> 返回<span class="hljs-selector-tag">QuerySet</span>对象的方法有：
      <span class="hljs-keyword">all</span>()
      <span class="hljs-selector-tag">filter</span>()
      <span class="hljs-selector-tag">exclude</span>()
      <span class="hljs-selector-tag">order_by</span>()
      <span class="hljs-selector-tag">reverse</span>()
      <span class="hljs-selector-tag">distinct</span>()
  特殊的<span class="hljs-selector-tag">QuerySet</span>：
      <span class="hljs-selector-tag">values</span>()       返回一个可迭代的字典序列
      <span class="hljs-selector-tag">values_list</span>() 返回一个可迭代的元组序列
  返回具体对象的：
      <span class="hljs-selector-tag">get</span>()
      <span class="hljs-selector-tag">first</span>()
      <span class="hljs-selector-tag">last</span>()
  返回布尔值的方法有：
      <span class="hljs-selector-tag">exists</span>()
  返回数字的方法有：
      <span class="hljs-selector-tag">count</span>()</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label196"></a></div><h2 id="only和defer的区别">33. only和defer的区别？</h2>
<pre><code class="hljs ruby"> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">defer</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, *fields)</span></span>:
    models.UserInfo.objects.defer(<span class="hljs-string">'username'</span>,<span class="hljs-string">'id'</span>)
    或
    models.UserInfo.objects.filter(...).defer(<span class="hljs-string">'username'</span>,<span class="hljs-string">'id'</span>)
    <span class="hljs-comment">#映射中排除某列数据</span>

 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">only</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, *fields)</span></span>:
    <span class="hljs-comment">#仅取某个表中的数据</span>
     models.UserInfo.objects.only(<span class="hljs-string">'username'</span>,<span class="hljs-string">'id'</span>)
     或
     models.UserInfo.objects.filter(...).only(<span class="hljs-string">'username'</span>,<span class="hljs-string">'id'</span>)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label197"></a></div><h2 id="select_related和prefetch_related的区别">34. select_related和prefetch_related的区别？</h2>
<pre><code class="hljs python"> title = models.CharField(max_length=<span class="hljs-number">32</span>)

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span><span class="hljs-params">(models.Model)</span>:</span>
      name = models.CharField(max_length=<span class="hljs-number">32</span>)
      email = models.CharField(max_length=<span class="hljs-number">32</span>)
      ut = models.ForeignKey(to=<span class="hljs-string">'UserType'</span>)
      ut = models.ForeignKey(to=<span class="hljs-string">'UserType'</span>)
      ut = models.ForeignKey(to=<span class="hljs-string">'UserType'</span>)
      ut = models.ForeignKey(to=<span class="hljs-string">'UserType'</span>)
      
      
  <span class="hljs-comment"># 1次SQL</span>
  <span class="hljs-comment"># select * from userinfo</span>
  objs = UserInfo.obejcts.all()
  <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> objs:
      print(item.name)
      
  <span class="hljs-comment"># n+1次SQL</span>
  <span class="hljs-comment"># select * from userinfo</span>
  objs = UserInfo.obejcts.all()
  <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> objs:
      <span class="hljs-comment"># select * from usertype where id = item.id </span>
      print(item.name,item.ut.title)

  示例<span class="hljs-number">1</span>:        
  .select_related()
      <span class="hljs-comment"># 1次SQL</span>
      <span class="hljs-comment"># select * from userinfo inner join usertype on userinfo.ut_id = usertype.id </span>
      objs = UserInfo.obejcts.all().select_related(<span class="hljs-string">'ut'</span>)
      <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> objs:
          print(item.name,item.ut.title)
  示例<span class="hljs-number">2</span>:
  .prefetch_related()
      <span class="hljs-comment"># select * from userinfo where id &lt;= 8</span>
      <span class="hljs-comment"># 计算：[1,2]</span>
      <span class="hljs-comment"># select * from usertype where id in [1,2]</span>
      objs = UserInfo.obejcts.filter(id__lte=<span class="hljs-number">8</span>).prefetch_related(<span class="hljs-string">'ut'</span>)
      <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> objs:
          print(obj.name,obj.ut.title)
  两个函数的作用都是减少查询次数</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label198"></a></div><h2 id="filter和exclude的区别">35. filter和exclude的区别？</h2>
<pre><code class="hljs ruby">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, *args, **kwargs)</span></span>
      <span class="hljs-comment"># 条件查询(符合条件)</span>
      <span class="hljs-comment"># 条件可以是：参数，字典，Q</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exclude</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, *args, **kwargs)</span></span>
      <span class="hljs-comment"># 条件查询(排除条件)</span>
      <span class="hljs-comment"># 条件可以是：参数，字典，Q</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label199"></a></div><h2 id="列举django-orm中三种能写sql语句的方法">36. 列举django orm中三种能写sql语句的方法。</h2>
<pre><code class="hljs sql">  1.使用<span class="hljs-keyword">execute</span>执行自定义<span class="hljs-keyword">SQL</span>
  # <span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> <span class="hljs-keyword">connection</span>, connections
  # <span class="hljs-keyword">cursor</span> = connection.cursor()  # <span class="hljs-keyword">cursor</span> = connections[<span class="hljs-string">'default'</span>].cursor()
  # cursor.execute(<span class="hljs-string">"""SELECT * from auth_user where id = %s"""</span>, [<span class="hljs-number">1</span>])
  # <span class="hljs-keyword">row</span> = cursor.fetchone()

  <span class="hljs-number">2.</span>使用extra方法 

  # extra(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">select</span>=<span class="hljs-keyword">None</span>, <span class="hljs-keyword">where</span>=<span class="hljs-keyword">None</span>, params=<span class="hljs-keyword">None</span>, <span class="hljs-keyword">tables</span>=<span class="hljs-keyword">None</span>, order_by=<span class="hljs-keyword">None</span>, select_params=<span class="hljs-keyword">None</span>)
  #    Entry.objects.extra(<span class="hljs-keyword">select</span>={<span class="hljs-string">'new_id'</span>: <span class="hljs-string">"select col from sometable where othercol &gt; %s"</span>}, select_params=(<span class="hljs-number">1</span>,))
  #    Entry.objects.extra(<span class="hljs-keyword">where</span>=[<span class="hljs-string">'headline=%s'</span>], params=[<span class="hljs-string">'Lennon'</span>])
  #    Entry.objects.extra(<span class="hljs-keyword">where</span>=[<span class="hljs-string">"foo='a' OR bar = 'a'"</span>, <span class="hljs-string">"baz = 'a'"</span>])
  #    Entry.objects.extra(<span class="hljs-keyword">select</span>={<span class="hljs-string">'new_id'</span>: <span class="hljs-string">"select id from tb where id &gt; %s"</span>}, select_params=(<span class="hljs-number">1</span>,), order_by=[<span class="hljs-string">'-nid'</span>])

  <span class="hljs-number">3.</span>使用<span class="hljs-keyword">raw</span>方法
  　　解释：执行原始<span class="hljs-keyword">sql</span>并返回模型
  　　说明：依赖<span class="hljs-keyword">model</span>多用于查询
  　　用法：
  　　　　book = Book.objects.raw(<span class="hljs-string">"select * from hello_book"</span>)
  　　　　<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> book:
  　　　　　　print(item.title)
  https://www.cnblogs.com/<span class="hljs-number">413</span>xiaol/p/<span class="hljs-number">6504856.</span>html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label200"></a></div><h2 id="django-orm-中如何设置读写分离">37. django orm 中如何设置读写分离？</h2>
<pre><code class="hljs python">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router1</span>:</span>
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allow_migrate</span><span class="hljs-params">(self, db, app_label, model_name=None, **hints)</span>:</span>
          <span class="hljs-string">"""
          All non-auth models end up in this pool.
          """</span>
          <span class="hljs-keyword">if</span> db==<span class="hljs-string">'db1'</span> <span class="hljs-keyword">and</span> app_label == <span class="hljs-string">'app02'</span>:
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
          <span class="hljs-keyword">elif</span> db == <span class="hljs-string">'default'</span> <span class="hljs-keyword">and</span> app_label == <span class="hljs-string">'app01'</span>:
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
          <span class="hljs-keyword">else</span>:
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
          
          <span class="hljs-comment"># 如果返回None，那么表示交给后续的router，如果后续没有router，则相当于返回True</span>
          
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">db_for_read</span><span class="hljs-params">(self, model, **hints)</span>:</span>
          <span class="hljs-string">"""
          Attempts to read auth models go to auth_db.
          """</span>
          <span class="hljs-keyword">if</span> model._meta.app_label == <span class="hljs-string">'app01'</span>:
              <span class="hljs-keyword">return</span> <span class="hljs-string">'default'</span>
          <span class="hljs-keyword">else</span>:
              <span class="hljs-keyword">return</span> <span class="hljs-string">'db1'</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">db_for_write</span><span class="hljs-params">(self, model, **hints)</span>:</span>
          <span class="hljs-string">"""
          Attempts to write auth models go to auth_db.
          """</span>
          <span class="hljs-keyword">if</span> model._meta.app_label == <span class="hljs-string">'app01'</span>:
              <span class="hljs-keyword">return</span> <span class="hljs-string">'default'</span>
          <span class="hljs-keyword">else</span>:
              <span class="hljs-keyword">return</span> <span class="hljs-string">'db1'</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label201"></a></div><h2 id="f和q的作用">38. F和Q的作用?</h2>
<pre><code class="hljs r">  <span class="hljs-literal">F</span>:
  Django 支持 <span class="hljs-literal">F</span>() 对象之间以及 <span class="hljs-literal">F</span>() 对象和常数之间的加减乘除和取模的操作。
  修改操作也可以使用<span class="hljs-literal">F</span>函数,比如将每一本书的价格提高<span class="hljs-number">30</span>元

  例:把所有书名后面加上(第一版)
      from django.db.models.functions import Concat
      from django.db.models import Value
      models.Book.objects.all().update(title=Concat(<span class="hljs-literal">F</span>(<span class="hljs-string">"title"</span>), Value(<span class="hljs-string">"("</span>), Value(<span class="hljs-string">"第一版"</span>), Value(<span class="hljs-string">")"</span>)))
  Q:
  Q(条件<span class="hljs-number">1</span>) | Q(条件<span class="hljs-number">2</span>) 或
  Q(条件<span class="hljs-number">1</span>) &amp; Q(条件<span class="hljs-number">2</span>) 且
  Q(条件<span class="hljs-number">1</span>) &amp; ~Q(条件<span class="hljs-number">2</span>) 非</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label202"></a></div><h2 id="values和values_list的区别">39. values和values_list的区别？</h2>
<pre><code class="hljs less">    <span class="hljs-selector-tag">values</span>()       返回一个可迭代的字典序列
    <span class="hljs-selector-tag">values_list</span>() 返回一个可迭代的元组序列</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label203"></a></div><h2 id="如何使用django-orm批量创建数据">40. 如何使用django orm批量创建数据？</h2>
<pre><code class="hljs ruby">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bulk_create</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, objs, batch_size=None)</span></span>:
        <span class="hljs-comment"># 批量插入</span>
        <span class="hljs-comment"># batch_size表示一次插入的个数</span>
        objs = [
            models.DDD(name=<span class="hljs-string">'r11'</span>),
            models.DDD(name=<span class="hljs-string">'r22'</span>)
        ]
        models.DDD.objects.bulk_create(objs, <span class="hljs-number">10</span>)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label204"></a></div><h2 id="django的form和modeform的作用">41. django的Form和ModeForm的作用？</h2>
<pre><code class="hljs haskell">  - 作用：
      - 对用户请求数据格式进行校验
      - 自动生成<span class="hljs-type">HTML</span>标签
  - 区别：
      - <span class="hljs-type">Form</span>，字段需要自己手写。
<span class="hljs-class">          <span class="hljs-keyword">class</span> <span class="hljs-type">Form</span>(<span class="hljs-type">Form</span>):
              xx = fields.<span class="hljs-type">CharField</span>(.)
              xx = fields.<span class="hljs-type">CharField</span>(.)
              xx = fields.<span class="hljs-type">CharField</span>(.)
              xx = fields.<span class="hljs-type">CharField</span>(.)
      - <span class="hljs-type">ModelForm</span>，可以通过<span class="hljs-type">Meta</span>进行定义
          <span class="hljs-keyword">class</span> <span class="hljs-type">MForm</span>(<span class="hljs-type">ModelForm</span>):
              <span class="hljs-keyword">class</span> <span class="hljs-type">Meta</span>:
                  fields = "__all__"
                  model = <span class="hljs-type">UserInfo</span>                            
  - 应用：只要是客户端向服务端发送表单数据时，都可以进行使用，如：用户登录注册</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label205"></a></div><h2 id="django的form组件中如果字段中包含choices参数请使用两种方式实现数据源实时更新">42. django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新。</h2>
<pre><code class="hljs python">  方式一:重写构造方法，在构造方法中重新去数据库获取值
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserForm</span><span class="hljs-params">(Form)</span>:</span>
      name = fields.CharField(label=<span class="hljs-string">'用户名'</span>,max_length=<span class="hljs-number">32</span>)
      email = fields.EmailField(label=<span class="hljs-string">'邮箱'</span>)
      ut_id = fields.ChoiceField(
          <span class="hljs-comment"># choices=[(1,'二B用户'),(2,'山炮用户')]</span>
          choices=[]
      )

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,*args,**kwargs)</span>:</span>
          super(UserForm,self).__init__(*args,**kwargs)

          self.fields[<span class="hljs-string">'ut_id'</span>].choices = models.UserType.objects.all().values_list(<span class="hljs-string">'id'</span>,<span class="hljs-string">'title'</span>)
  方式二: ModelChoiceField字段
  <span class="hljs-keyword">from</span> django.forms <span class="hljs-keyword">import</span> Form
  <span class="hljs-keyword">from</span> django.forms <span class="hljs-keyword">import</span> fields
  <span class="hljs-keyword">from</span> django.forms.models <span class="hljs-keyword">import</span> ModelChoiceField
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserForm</span><span class="hljs-params">(Form)</span>:</span>
      name = fields.CharField(label=<span class="hljs-string">'用户名'</span>,max_length=<span class="hljs-number">32</span>)
      email = fields.EmailField(label=<span class="hljs-string">'邮箱'</span>)
      ut_id = ModelChoiceField(queryset=models.UserType.objects.all())    

  依赖：
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserType</span><span class="hljs-params">(models.Model)</span>:</span>
          title = models.CharField(max_length=<span class="hljs-number">32</span>)

          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
              <span class="hljs-keyword">return</span> self.title</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label206"></a></div><h2 id="django的model中的foreignkey字段中的on_delete参数有什么作用">43. django的Model中的ForeignKey字段中的on_delete参数有什么作用？</h2>
<pre><code class="hljs sql">  on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、<span class="hljs-keyword">SET</span>()五个可选择的值

    <span class="hljs-keyword">CASCADE</span>：此值设置，是级联删除。

    PROTECT：此值设置，是会报完整性错误。

    SET_NULL：此值设置，会把外键设置为<span class="hljs-literal">null</span>，前提是允许为<span class="hljs-literal">null</span>。

    SET_DEFAULT：此值设置，会把设置为外键的默认值。

    <span class="hljs-keyword">SET</span>()：此值设置，会调用外面的值，可以是一个函数。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label207"></a></div><h2 id="django中csrf的实现机制">44. django中csrf的实现机制？</h2>
<pre><code class="hljs awk">  Django预防CSRF攻击的方法是在用户提交的表单中加入一个csrftoken的隐含值，这个值和服务器中保存的csrftoken的值相同，这样做的原理如下:

  <span class="hljs-number">1</span>、在用户访问django的可信站点时，django反馈给用户的表单中有一个隐含字段csrftoken，这个值是在服务器端随机生成的，每一次提交表单都会生成不同的值

  <span class="hljs-number">2</span>、当用户提交django的表单时，服务器校验这个表单的csrftoken是否和自己保存的一致，来判断用户的合法性

  <span class="hljs-number">3</span>、当用户被csrf攻击从其他站点发送精心编制的攻击请求时，由于其他站点不可能知道隐藏的csrftoken字段的信息这样在服务器端就会校验失败，攻击被成功防御

  具体配置如下：

  template中添加{%csrf_token%}标签
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/u012556900/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">57412707</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label208"></a></div><h2 id="django如何实现websocket">45. django如何实现websocket？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/huguodong/p/6611602.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label209"></a></div><h2 id="基于django使用ajax发送post请求时都可以使用哪种方法携带csrf-token">46. 基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？</h2>
<pre><code class="hljs less">  三种方式：
    <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/wxp5257/p/7834090.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label210"></a></div><h2 id="django中如何实现orm表中添加数据时创建一条日志记录">47. django中如何实现orm表中添加数据时创建一条日志记录。</h2>
<pre><code class="hljs php">LOGGING配置查看翻译的SQL：
    在Django的日志设置中，配置上一个名为django.db.backends的logger实例即可查看翻译后的SQL语句。
    LOGGING = {
        <span class="hljs-string">'version'</span>: <span class="hljs-number">1</span>,
        <span class="hljs-string">'disable_existing_loggers'</span>: <span class="hljs-keyword">False</span>,
        <span class="hljs-string">'handlers'</span>: {
            <span class="hljs-string">'console'</span>:{
                <span class="hljs-string">'level'</span>:<span class="hljs-string">'DEBUG'</span>,
                <span class="hljs-string">'class'</span>:<span class="hljs-string">'logging.StreamHandler'</span>,
            },
        },
        <span class="hljs-string">'loggers'</span>: {
            <span class="hljs-string">'django.db.backends'</span>: {
                <span class="hljs-string">'handlers'</span>: [<span class="hljs-string">'console'</span>],
                <span class="hljs-string">'propagate'</span>: <span class="hljs-keyword">True</span>,
                <span class="hljs-string">'level'</span>:<span class="hljs-string">'DEBUG'</span>,
            },
        }
    }　　
    http:<span class="hljs-comment">//www.cnblogs.com/owasp/p/5981355.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label211"></a></div><h2 id="django缓存如何设置">48. django缓存如何设置？</h2>
<pre><code class="hljs django"><span class="xml">  三种粒度缓存
   1 中间件级别
       'django.middleware.cache.UpdateCacheMiddleware',
       'django.middleware.cache.FetchFromCacheMiddleware',
        CACHE_MIDDLEWARE_SECONDS=10
   
   2 视图级别
   
      from django.views.decorators.cache import cache_page
      @cache_page(15)
      def index(request):
          import time
          t=time.time()
          return render(request,"index.html",locals())
      
  
   3 局部缓存
      </span><span class="hljs-template-tag">{% <span class="hljs-name"><span class="hljs-name">load</span></span> cache %}</span><span class="xml">
          ...
          ...
      </span><span class="hljs-template-tag">{% <span class="hljs-name">cache</span> 15 "time_cache" %}</span><span class="xml">
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>缓存时间:</span><span class="hljs-template-variable">{{ t }}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      </span><span class="hljs-template-tag">{% <span class="hljs-name">endcache</span> %}</span><span class="xml"></span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label212"></a></div><h2 id="django的缓存能使用redis吗如果可以的话如何配置">49. django的缓存能使用redis吗？如果可以的话，如何配置？</h2>
<pre><code class="hljs accesslog">  pip install django-redis
  apt-get install redis-server

  然后在settings.py 里面添加CACHES = {
  'default': {
  'BACKEND': 'redis_cache.cache.RedisCache',
  'LOCATION': '<span class="hljs-number">127.0.0.1:6379</span>',
  <span class="hljs-string">"<span class="hljs-keyword">OPTIONS</span>"</span>: {
  <span class="hljs-string">"CLIENT_CLASS"</span>: <span class="hljs-string">"redis_cache.client.DefaultClient"</span>,
  },
  }</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label213"></a></div><h2 id="django路由系统中name的作用">50. django路由系统中name的作用？</h2>
<pre><code class="hljs awk">    简单说，name 可以用于在 templates, models, views ……中得到对应的网址，相当于“给网址取了个名字”，只要这个名字不变，网址变了也能通过名字获取到。
    https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/liweiblog/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">77599604</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label214"></a></div><h2 id="django的模板中filter和simple_tag的区别">51. django的模板中filter和simple_tag的区别？</h2>
<pre><code class="hljs ruby">  simple_tag
  　　-参数任意，但是不能作为<span class="hljs-keyword">if</span>条件判断的条件
  filter 
  　　-参数最多只能有两个，但是可以作为<span class="hljs-keyword">if</span>条件判断的条件。
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/cerofang</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8367588</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label215"></a></div><h2 id="django-debug-toolbar的作用">52. django-debug-toolbar的作用？</h2>
<pre><code class="hljs awk">  django_debug_toolbar 是django的第三方工具包，给django扩展了调试功能。
  包括查看执行的sql语句，db查询次数，request，headers，调试概览等。 
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/weixin_39198406/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">78821677</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label216"></a></div><h2 id="django中如何实现单元测试">53. django中如何实现单元测试？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.jianshu.com/p/34267dd79ad6</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label217"></a></div><h2 id="解释orm中-db-first-和-code-first的含义">54. 解释orm中 db first 和 code first的含义？</h2>
<pre><code class="hljs nginx">  <span class="hljs-attribute">datebase</span>  first就是代表数据库优先，那么前提就是先创建数据库。
  model first就是代表model优先，那么前提也就是先创建model，然后根据model自动建立数据库。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label218"></a></div><h2 id="django中如何根据数据库表生成model中的类">55. django中如何根据数据库表生成model中的类？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//jingyan.baidu.com/article/4ae03de3e513d23eff9e6bb7.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label219"></a></div><h2 id="使用orm和原生sql的优缺点">56. 使用orm和原生sql的优缺点？</h2>
<pre><code class="hljs haskell">  <span class="hljs-type">ORM</span>框架：

  　　对象关系映射，通过创建一个类，这个类与数据库的表相对应！类的对象代指数据库中的一行数据。

  简述<span class="hljs-type">ORM</span>原理：
  　　让用户不再写<span class="hljs-type">SQL</span>语句，而是通过类以及对象的方式，和其内部提供的方法，进行数据库操作！把用户输入的类或对象转换成<span class="hljs-type">SQL</span>语句，转换之后通过pymysql执行完成数据库的操作。

  <span class="hljs-type">ORM</span>的优缺点：

  优点： 
  　　提高开发效率，降低开发成本 
  　　使开发更加对象化 
  　　可移植 
  　　可以很方便地引入数据缓存之类的附加功能 
  缺点： 
  　　在处理多表联查、<span class="hljs-keyword">where</span>条件复杂之类的查询时，<span class="hljs-type">ORM</span>的语法会变得复杂。就需要写入原生<span class="hljs-type">SQL</span>。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label220"></a></div><h2 id="简述mvc和mtv">57. 简述MVC和MTV</h2>
<pre><code class="hljs"> MTV和MVC？
        
  MVC： model view controller          
  MTV： model tempalte view    </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label221"></a></div><h2 id="django的contenttype组件的作用">58. django的contenttype组件的作用？</h2>
<pre><code class="hljs ruby">  contenttype是django的一个组件（app），为我们找到django程序中所有app中的所有表并添加到记录中。
        
        可以使用他再加上表中的两个字段实现：一张表和N张表创建FK关系。
            - 字段：表名称
            - 字段：数据行ID
            
        应用：路飞表结构优惠券和专题课和学位课关联。
        <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/iyouyue</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8810464</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label222"></a></div><h2 id="谈谈你对restfull-规范的认识">59. 谈谈你对restfull 规范的认识？</h2>
<pre><code class="hljs sql">  - restful其实就是一套编写接口的协议，协议规定如何编写以及如何设置返回值、状态码等信息。
    - 最显著的特点：
        restful: 给用户一个url，根据method不同在后端做不同的处理，比如：post 创建数据、get获取数据、put和patch修改数据、<span class="hljs-keyword">delete</span>删除数据。
        <span class="hljs-keyword">no</span> rest: 给调用者很多<span class="hljs-keyword">url</span>，每个<span class="hljs-keyword">url</span>代表一个功能，比如：add_user/delte_user/edit_user/
    - 当然，还有协议其他的，比如：
        - 版本，来控制让程序有多个版本共存的情况，版本可以放在 <span class="hljs-keyword">url</span>、请求头（<span class="hljs-keyword">accept</span>/自定义）、<span class="hljs-keyword">GET</span>参数
        - 状态码，<span class="hljs-number">200</span>/<span class="hljs-number">300</span>/<span class="hljs-number">400</span>/<span class="hljs-number">500</span>
        - <span class="hljs-keyword">url</span>中尽量使用名词，restful也可以称为“面向资源编程”
        - api标示：
            api.YueNet.com
            www.YueNet.com/api/
  <span class="hljs-comment">-------------------------------------------------</span>
    - https
    - 域名 
        - api.oldboy.com
        - www.oldboy.com/api
    - 版本：
        - www.oldboy.com/api/v1

    - <span class="hljs-keyword">URL</span>资源，名词
        - www.oldboy.com/api/v1/student

    - 请求方式：
        - <span class="hljs-keyword">GET</span>/POST/PUT/<span class="hljs-keyword">DELETE</span>/<span class="hljs-keyword">PATCH</span>/OPTIONS/HEADERS/<span class="hljs-keyword">TRACE</span>
    - 返回值：
        - www.oldboy.com/api/v1/student/    -&gt; 结果集
        - www.oldboy.com/api/v1/student/<span class="hljs-number">1</span>/  -&gt; 单个对象
    - <span class="hljs-keyword">URL</span>添加条件
        - www.oldboy.com/api/v1/student？page=<span class="hljs-number">11</span>&amp;<span class="hljs-keyword">size</span>=<span class="hljs-number">9</span>
    - 状态码：  
        - <span class="hljs-number">200</span>
        - <span class="hljs-number">300</span>
            - <span class="hljs-number">301</span>
            - <span class="hljs-number">302</span>
        - <span class="hljs-number">400</span>
            - <span class="hljs-number">403</span>
            - <span class="hljs-number">404</span>
        - <span class="hljs-number">500</span>
    - 错误信息
        {
            code:<span class="hljs-number">1000</span>,
            meg:<span class="hljs-string">'xxxx'</span>
        }
    - hyperlink
        {
            <span class="hljs-keyword">id</span>：<span class="hljs-number">1</span>
            <span class="hljs-keyword">name</span>: ‘xiangl’,
            <span class="hljs-keyword">type</span>: <span class="hljs-keyword">http</span>://www.xxx.com/api/v1/<span class="hljs-keyword">type</span>/<span class="hljs-number">1</span>/
        }</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label223"></a></div><h2 id="接口的幂等性是什么意思">60. 接口的幂等性是什么意思？</h2>
<pre><code class="hljs vbscript">  一个接口通过首先进行<span class="hljs-number">1</span>次访问，然后对该接口进行N次相同访问的时候，对访问对象不造成影响，那么就认为接口具有幂等性。
  比如：
      <span class="hljs-keyword">GET</span>，  第一次获取数据、第二次也是获取结果，幂等。
      POST， 第一次新增数据，第二次也会再次新增，非幂等。
      PUT，  第一次更新数据，第二次不会再次更新，幂等。
      PATCH，第一次更新数据，第二次可能再次更新，非幂等。
      DELTE，第一次删除数据，第二次不会再次删除，幂等。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label224"></a></div><h2 id="什么是rpc">61. 什么是RPC？</h2>
<pre><code class="hljs delphi">
  RPC（Remote <span class="hljs-function"><span class="hljs-keyword">Procedure</span> <span class="hljs-title">Call</span>）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<span class="hljs-title">RPC</span>协议假定某些传输协议的存在，如<span class="hljs-title">TCP</span>或<span class="hljs-title">UDP</span>，为通信程序之间携带信息数据。在<span class="hljs-title">OSI</span>网络通信模型中，<span class="hljs-title">RPC</span>跨越了传输层和应用层。<span class="hljs-title">RPC</span>使得开发包括网络分布式多程序在内的应用程序更加容易。</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label225"></a></div><h2 id="http和https的区别">62. Http和Https的区别？</h2>
<pre><code class="hljs ruby">  　　超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

  　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/wqhwe</span><span class="hljs-regexp">/p/</span><span class="hljs-number">5407468</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label226"></a></div><h2 id="为什么要使用django-rest-framework框架">63. 为什么要使用django rest framework框架？</h2>
<pre><code class="hljs ruby">  　　<span class="hljs-number">1</span>.客户端-服务端分离

  　　　优点：提高用户界面的便携性，通过简化服务器提高可伸缩性....

  　　<span class="hljs-number">2</span>.无状态（Stateless）：从客户端的每个请求要包含服务器所需要的所有信息

  　　  优点：提高可见性（可以单独考虑每个请求），提高了可靠性（更容易从局部故障中修复），提高可扩展性（降低了服务器资源使用）

  　　<span class="hljs-number">3</span>.缓存（Cachable）：服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的信息发送请求

  　　 优点：减少交互次数，减少交互的平均延迟

  　　<span class="hljs-number">4</span>.统一接口

  　　 优点：提高交互的可见性，鼓励单独改善组件

  　　<span class="hljs-number">5</span>.支持按需代码（Code-On-Demand 可选）

  　　优点：提高可扩展性
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/vipchenwei</span><span class="hljs-regexp">/p/</span><span class="hljs-number">7867028</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label227"></a></div><h2 id="django-rest-framework框架中都有那些组件">64. django rest framework框架中都有那些组件？</h2>
<pre><code class="hljs ruby">  - 路由，自动帮助开发者快速为一个视图创建<span class="hljs-number">4</span>个url
            www.oldboyedu.com/api/v1/student/$
            www.oldboyedu.com/api/v1/student(<span class="hljs-string">?P</span>&lt;format&gt;\w+)$
            
            www.oldboyedu.com/api/v1/student/(<span class="hljs-string">?P</span>&lt;pk&gt;\d+)/$
            www.oldboyedu.com/api/v1/student/(<span class="hljs-string">?P</span>&lt;pk&gt;\d+)(<span class="hljs-string">?P</span>&lt;format&gt;\w+)$
            
    - 版本处理
        - 问题：版本都可以放在那里？
                - url
                - GET 
                - 请求头 
    - 认证 
        - 问题：认证流程？

    - 权限 
        - 权限是否可以放在中间件中？以及为什么？

    - 访问频率的控制
        - 匿名用户可以真正的防止？无法做到真正的访问频率控制，只能把小白拒之门外。
          如果要封IP，使用防火墙来做。
          
        - 登录用户可以通过用户名作为唯一标示进行控制，如果有人注册很多账号，也无法防止。

    - 视图

    - 解析器 ，根据Content-Type请求头对请求体中的数据格式进行处理。request.data 

    - 分页

    - 序列化
        - 序列化
            - source
            - 定义方法
        - 请求数据格式校验

    - 渲染器</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label228"></a></div><h2 id="django-rest-framework框架中的视图都可以继承哪些类">65. django rest framework框架中的视图都可以继承哪些类？</h2>
<pre><code class="hljs ruby">  a. 继承 APIView
      这个类属于rest framework中顶层类，内部帮助我们实现了只是基本功能：认证、权限、频率控制，但凡是数据库、分页等操作都需要手动去完成，比较原始。
      
  
  
     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericAPIView</span>(<span class="hljs-title">APIView</span>)</span>
          
          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span><span class="hljs-params">(...)</span></span>:
              pass 
          
  b. 继承 GenericViewSet(ViewSetMixin, generics.GenericAPIView)
      如果继承它之后，路由中的as_view需要填写对应关系    .as_view({<span class="hljs-string">'get'</span><span class="hljs-symbol">:<span class="hljs-string">'list'</span></span>,<span class="hljs-string">'post'</span><span class="hljs-symbol">:<span class="hljs-string">'create'</span></span>})
      在内部也帮助我们提供了一些方便的方法：
          - get_queryset
          - get_object
          - get_serializer
      
      注意：要设置queryset字段，否则会跑出断言的异常。
      <span class="hljs-comment"># 只提供增加功能</span>
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestView</span>(<span class="hljs-title">GenericViewSet</span>):</span>
          serializer_class = XXXXXXX

          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">self</span>,*args,**kwargs)</span></span>:
              pass <span class="hljs-comment"># 获取数据并对数据进行操作</span>
      
  c. 继承 
          - ModelViewSet
          - mixins.CreateModelMixin,GenericViewSet
          - mixins.CreateModelMixin,DestroyModelMixin,GenericViewSet
  
      对数据库和分页等操作不用我们在编写，只需要继承相关类即可。
      
      示例：只提供增加功能
      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestView</span>(<span class="hljs-title">mixins</span>.<span class="hljs-title">CreateModelMixin</span>,<span class="hljs-title">GenericViewSet</span>):</span>
          serializer_class = XXXXXXX
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/iyouyue</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8798572</span>.html<span class="hljs-comment">#_label3</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label229"></a></div><h2 id="简述-django-rest-framework框架的认证流程">66. 简述 django rest framework框架的认证流程。</h2>
<pre><code class="hljs awk">  - 如何编写？写类并实现authticate
  - 方法中可以定义三种返回值：
      - （user,auth），认证成功
      - None , 匿名用户
      - 异常 ，认证失败
  - 流程：
      - dispatch 
      - 再去request中进行认证处理
  https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/haiyan123/</span>p<span class="hljs-regexp">/8419872.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label230"></a></div><h2 id="django-rest-framework如何实现的用户访问频率控制">67. django rest framework如何实现的用户访问频率控制？</h2>
<pre><code class="hljs ruby">  a. 基于用户IP限制访问频率
  b. 基于用户IP显示访问频率（利于Django缓存）　
  c. view中限制请求频率
  d. 匿名时用IP限制+登录时用Token限制
  e. 全局使用
  REST_FRAMEWORK = {
    <span class="hljs-string">'DEFAULT_THROTTLE_CLASSES'</span>: [
        <span class="hljs-string">'api.utils.throttles.throttles.LuffyAnonRateThrottle'</span>,
        <span class="hljs-string">'api.utils.throttles.throttles.LuffyUserRateThrottle'</span>,
    ],
    <span class="hljs-string">'DEFAULT_THROTTLE_RATES'</span>: {
        <span class="hljs-string">'anon'</span>: <span class="hljs-string">'10/day'</span>,
        <span class="hljs-string">'user'</span>: <span class="hljs-string">'10/day'</span>,
        <span class="hljs-string">'luffy_anon'</span>: <span class="hljs-string">'10/m'</span>,
        <span class="hljs-string">'luffy_user'</span>: <span class="hljs-string">'20/m'</span>,
    },
  }
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/vipchenwei</span><span class="hljs-regexp">/p/</span><span class="hljs-number">7867028</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label231"></a></div><h2 id="flask框架的优势">68. Flask框架的优势？</h2>
<pre><code class="hljs css">  一、整体设计方面
  首先，两者都是非常优秀的框架。整体来讲，两者设计的哲学是区别最大的地方。<span class="hljs-selector-tag">Django</span>提供一站式的解决方案，从模板、<span class="hljs-selector-tag">ORM</span>、<span class="hljs-selector-tag">Session</span>、<span class="hljs-selector-tag">Authentication</span>等等都分配好了，连<span class="hljs-selector-tag">app</span>划分都做好了，总之，为你做尽量多的事情，而且还有一个<span class="hljs-selector-tag">killer</span>级的特性，就是它的<span class="hljs-selector-tag">admin</span>，配合<span class="hljs-selector-tag">django-suit</span>，后台就出来了，其实最初<span class="hljs-selector-tag">Django</span>就是由在新闻发布公司工作的人设计的。<span class="hljs-selector-tag">Flask</span>只提供了一些核心功能，非常简洁优雅。它是一个微框架，其他的由扩展提供，但它的<span class="hljs-selector-tag">blueprint</span>使它也能够很方便的进行水平扩展。
  二、路由设计
  <span class="hljs-selector-tag">Django</span>的路由设计是采用集中处理的方法，利用正则匹配。<span class="hljs-selector-tag">Flask</span>也能这么做，但更多的是使用装饰器的形式，这个有优点也有缺点，优点是读源码时看到函数就知道怎么用的，缺点是一旦源码比较长，你要查路由就不太方便了，但这也促使你去思考如何更合理的安排代码。
  三、应用模块化设计
  <span class="hljs-selector-tag">Django</span>的模块化是集成在命令里的，也就是说一开始<span class="hljs-selector-tag">Django</span>的目标就是为以后玩大了做准备的。每个都是一个独立的模块，为以后的复用提供了便利。<span class="hljs-selector-tag">Flask</span>通过<span class="hljs-selector-tag">Blueprint</span>来提供模块化，自己对项目结构划分成不同的模块进行组织。
  四、配置
  <span class="hljs-selector-tag">Django</span>的配置主要还是靠<span class="hljs-selector-tag">settings</span><span class="hljs-selector-class">.py</span>来做，当然为了<span class="hljs-selector-tag">Development</span>和<span class="hljs-selector-tag">Production</span>环境分离，还有一些方法来处理配置。<span class="hljs-selector-tag">Flask</span>的配置很灵活，有多种方法配置，不同环境的配置也非常方便。
  五、文档
  两者都提供了详尽的文档，<span class="hljs-selector-tag">Flask</span>的文档风格很受我个人喜好，<span class="hljs-selector-tag">Django</span>的文档也非常优秀，当时用学<span class="hljs-selector-tag">Django</span>时，就是只看了<span class="hljs-selector-tag">Django</span>的文档。
  六、社区
  <span class="hljs-selector-tag">Django</span>社区很大，各种插件很齐全，大部分情况下你都能找到你想要的。<span class="hljs-selector-tag">Flask</span>起步晚，但社区也不小，之前有一次看在<span class="hljs-selector-tag">github</span>上的<span class="hljs-selector-tag">star</span>数，两个相差并不远，说明越来越多的人关注它，虽然插件没那么全，但常用的还都是有的，而且质量都比较高。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label232"></a></div><h2 id="flask框架依赖组件">69. Flask框架依赖组件？</h2>
<pre><code class="hljs">  Flask依赖两个外部库：
    Jinja2模板引擎
    Werkzeng WSGI工具集。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label233"></a></div><h2 id="flask蓝图的作用">70. Flask蓝图的作用？</h2>
<pre><code class="hljs">    将不同的功能 模块化；
    构建大型的应用；
    优化项目结构；
    增强可读性，易于维护；</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label234"></a></div><h2 id="列举使用过的flask第三方组件">71. 列举使用过的Flask第三方组件？</h2>
<pre><code class="hljs">  内置:
      - 配置
          - 路由
          - 视图
          - 模板
          - session
          - 闪现
          - 蓝图
          - 中间件
          - 特殊装饰器
  第三方:
      - Flask组件：
          - flask-session 
          - flask-SQLAlchemy
          - flask-migrate 
          - flask-script 
          - blinker 
      - 公共组件：
          - wtforms
          - dbutile
          - sqlalchemy 
      - 自定义Flask组件
          - auth ，参考flask-login组件</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label235"></a></div><h2 id="简述flask上下文管理流程">72. 简述Flask上下文管理流程?</h2>
<pre><code class="hljs ruby">  每次有请求过来的时候，flask 会先创建当前线程或者进程需要处理的两个重要上下文对象，把它们保存到隔离的栈里面，这样视图函数进行处理的时候就能直接从栈上获取这些信息。
  参考链接<span class="hljs-symbol">:http</span><span class="hljs-symbol">://python</span>.jobbole.com/<span class="hljs-number">87398</span>/</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label236"></a></div><h2 id="flask中的g的作用">73. Flask中的g的作用？</h2>
<pre><code class="hljs delphi">    g 相当于一次请求的全局变量，当请求进来时将g和current_app封装为一个APPContext类，在通过LocalStack将Appcontext放入<span class="hljs-keyword">Local</span>中，取值时通过偏函数，LocalStack、loca　l中取值，响应时将<span class="hljs-keyword">local</span>中的g数据删除</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label237"></a></div><h2 id="flask中上下文管理主要涉及到了那些相关的类并描述类主要作用">74. Flask中上下文管理主要涉及到了那些相关的类？并描述类主要作用？</h2>
<pre><code class="hljs nginx">  <span class="hljs-attribute">flask</span>
  requestcontext
  request
  securecookiesessioninterface
  securecookiesession</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label238"></a></div><h2 id="为什么要flask把local对象中的的值stack-维护成一个列表">75. 为什么要Flask把Local对象中的的值stack 维护成一个列表？</h2>
<pre><code class="hljs less">    当是<span class="hljs-selector-tag">web</span>应用时：不管是单线程还是多线程，栈中只有一个数据
　　 <span class="hljs-selector-tag">-</span> 服务端单线程：
　　　　{
　　　　<span class="hljs-attribute">111</span>:{<span class="hljs-attribute">stack</span>: [ctx, ]}
　　　　}
　　<span class="hljs-selector-tag">-</span> 服务端多线程：
　　　　{
　　　　<span class="hljs-attribute">111</span>:{<span class="hljs-attribute">stack</span>: [ctx, ]}
　　　　<span class="hljs-attribute">112</span>:{<span class="hljs-attribute">stack</span>: [ctx, ]}
　　　　}</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label239"></a></div><h2 id="flask中多app应用是怎么完成">76. Flask中多app应用是怎么完成？</h2>
<pre><code class="hljs python">  目的是想要将local中的值维护成一个栈，例如：在多app应用中编写离线脚本时，可以实用上。
  <span class="hljs-keyword">from</span> m_app <span class="hljs-keyword">import</span> app01,app02
  <span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> current_app
  <span class="hljs-string">"""
  {
      1231: {
          stack: [app01,app02,]
      }
  }

  """</span>

  <span class="hljs-keyword">with</span> app01.app_context():
      print(current_app)
      <span class="hljs-keyword">with</span> app02.app_context():
          print(current_app)
      print(current_app)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label240"></a></div><h2 id="在flask中实现websocket需要什么组件">77. 在Flask中实现WebSocket需要什么组件？</h2>
<pre><code class="hljs awk">  Flask-SocketIO
  Flask-Sockets是Flask框架的一个扩展，通过它，Flask应用程序可以使用WebSocket。
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/u013793383/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">72848252</span>
  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/miguelgrinberg/</span>Flask-SocketIO</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label241"></a></div><h2 id="wtforms组件的作用">78. wtforms组件的作用？</h2>
<pre><code class="hljs javascript"> WTForms是一个支持多个web框架的form组件，主要用于对用户请求数据进行验证。
 https:<span class="hljs-comment">//www.cnblogs.com/big-handsome-guy/p/8552079.html</span>
 https:<span class="hljs-comment">//www.cnblogs.com/liuwei0824/p/8330985.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label242"></a></div><h2 id="flask框架默认session处理机制">79. Flask框架默认session处理机制？</h2>
<pre><code class="hljs less">  <span class="hljs-selector-tag">Flask</span>的默认<span class="hljs-selector-tag">session</span>利用了<span class="hljs-selector-tag">Werkzeug</span>的<span class="hljs-selector-tag">SecureCookie</span>，把信息做序列化(pickle)后编码(base64)，放到<span class="hljs-selector-tag">cookie</span>里了。

  过期时间是通过<span class="hljs-selector-tag">cookie</span>的过期时间实现的。

  为了防止<span class="hljs-selector-tag">cookie</span>内容被篡改，<span class="hljs-selector-tag">session</span>会自动打上一个叫<span class="hljs-selector-tag">session</span>的<span class="hljs-selector-tag">hash</span>串，这个串是经过<span class="hljs-selector-tag">session</span>内容、<span class="hljs-selector-tag">SECRET_KEY</span>计算出来的，看得出，这种设计虽然不能保证<span class="hljs-selector-tag">session</span>里的内容不泄露，但至少防止了不被篡改。
  <span class="hljs-selector-tag">https</span>:<span class="hljs-comment">//blog.csdn.net/qq_33733970/article/details/79008831</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label243"></a></div><h2 id="解释flask框架中的local对象和threading.local对象的区别">80. 解释Flask框架中的Local对象和threading.local对象的区别？</h2>
<pre><code class="hljs python"> a. threading.local
    作用：为每个线程开辟一块空间进行数据存储。

    问题：自己通过字典创建一个类似于threading.local的东西。
        storage={
            <span class="hljs-number">4740</span>:{val:<span class="hljs-number">0</span>},
            <span class="hljs-number">4732</span>:{val:<span class="hljs-number">1</span>},
            <span class="hljs-number">4731</span>:{val:<span class="hljs-number">3</span>},
            ...
        }

    b. 自定义Local对象
    作用：为每个线程(协程)开辟一块空间进行数据存储。

        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">from</span> greenlet <span class="hljs-keyword">import</span> getcurrent <span class="hljs-keyword">as</span> get_ident
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> get_ident

        <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
        <span class="hljs-keyword">import</span> time

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Local</span><span class="hljs-params">(object)</span>:</span>

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
                object.__setattr__(self,<span class="hljs-string">'storage'</span>,{})

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span><span class="hljs-params">(self, k, v)</span>:</span>
                ident = get_ident()
                <span class="hljs-keyword">if</span> ident <span class="hljs-keyword">in</span> self.storage:
                    self.storage[ident][k] = v
                <span class="hljs-keyword">else</span>:
                    self.storage[ident] = {k: v}

            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, k)</span>:</span>
                ident = get_ident()
                <span class="hljs-keyword">return</span> self.storage[ident][k]

        obj = Local()

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span><span class="hljs-params">(arg)</span>:</span>
            obj.val = arg
            obj.xxx = arg
            print(obj.val)

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
            t = Thread(target=task,args=(i,))
            t.start()</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label244"></a></div><h2 id="flask中-blinker-是什么">81. Flask中 blinker 是什么？</h2>
<pre><code class="hljs awk">  Flask框架中的信号基于blinker，可以让开发者在flask请求过程中 定制一些用户行为执行。

  在请求前后，模板渲染前后，上下文前后，异常 的时候
  http:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/big-handsome-guy/</span>p<span class="hljs-regexp">/8551973.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label245"></a></div><h2 id="sqlalchemy中的-session和scoped_session-的区别">82. SQLAlchemy中的 session和scoped_session 的区别？</h2>
<pre><code class="hljs ruby">  使用scoped_session的目的主要是为了线程安全。
  scoped_session类似单例模式，当我们调用使用的时候，会先在Registry里找找之前是否已经创建session了。
  要是有，就把这个session返回。
  要是没有，就创建新的session，注册到Registry中以便下次返回给调用者。
  这样就实现了这样一个目的：在同一个线程中，call scoped_session 的时候，返回的是同一个对象
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/geeklove</span>01/p/<span class="hljs-number">8179220</span>.html
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/lianxuebin</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8664401</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label246"></a></div><h2 id="sqlalchemy如何执行原生sql">83. SQLAlchemy如何执行原生SQL？</h2>
<pre><code class="hljs javascript">  <span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine
  <span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker

  engine = create_engine(<span class="hljs-string">'mysql://root:*****@127.0.0.1/database?charset=utf8'</span>)
  DB_Session = sessionmaker(bind=engine)
  session = DB_Session()
  session.execute(<span class="hljs-string">'alter table mytablename drop column mycolumn ;'</span>)

  https:<span class="hljs-comment">//www.cnblogs.com/franknihao/p/7268752.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label247"></a></div><h2 id="orm的实现原理">84. ORM的实现原理？</h2>
<pre><code class="hljs javascript">  概念： 对象关系映射（<span class="hljs-built_in">Object</span> Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。

  详细介绍：  让我们从O/R开始。字母O起源于<span class="hljs-string">"对象"</span>(<span class="hljs-built_in">Object</span>),而R则来自于<span class="hljs-string">"关系"</span>(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。
          当你开发一个应用程序的时候(不使用O/R Mapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 
          ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。 
  ORM技术特点： 
  <span class="hljs-number">1.</span>提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 
  <span class="hljs-number">2.</span>ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label248"></a></div><h2 id="dbutils模块的作用">85. DBUtils模块的作用？</h2>
<pre><code class="hljs awk">  使用DBUtils模块
  两种使用模式：
      <span class="hljs-number">1</span> 为每个线程创建一个连接，连接不可控，需要控制线程数
      <span class="hljs-number">2</span> 创建指定数量的连接在连接池，当线程访问的时候去取，如果不够了线程排队，直到有人释放。平时建议使用这种！
  https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/ArmoredTitan/</span>p<span class="hljs-regexp">/Flask.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label249"></a></div><h2 id="以下sqlalchemy的字段是否正确如果不正确请更正">86. 以下SQLAlchemy的字段是否正确？如果不正确请更正：</h2>
<pre><code class="hljs shell"><span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># from datetime import datetime</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># from sqlalchemy.ext.declarative</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># import declarative_base</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># from sqlalchemy import Column, Integer, String, DateTime</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># </span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># Base = declarative_base()</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment"># class UserInfo(Base):</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     __tablename__ = 'userinfo'  </span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     id = Column(Integer, primary_key=True, autoincrement=True)</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     name = Column(String(64), unique=True)</span></span>
<span class="hljs-meta">  #</span><span class="bash"><span class="hljs-comment">#     ctime = Column(DateTime, default=datetime.now())</span></span>
  ctime字段中的参数应该为default=datetime.now, now后面不应该加括号.如果加了,字段不会随时更新</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label250"></a></div><h2 id="sqlalchemy中如何为表设置引擎和字符编码">87. SQLAlchemy中如何为表设置引擎和字符编码？</h2>
<pre><code class="hljs php">
  sqlalchemy设置编码字符集一定要在数据库访问的URL上增加charset=utf8，否则数据库的连接就不是utf8的编码格式
  eng = create_engine(<span class="hljs-string">'mysql://root:root@localhost:3306/test2?charset=utf8'</span>,<span class="hljs-keyword">echo</span>=<span class="hljs-keyword">True</span>)</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label251"></a></div><h2 id="sqlalchemy中如何设置联合唯一索引">88. SQLAlchemy中如何设置联合唯一索引？</h2>
<pre><code class="hljs awk">    UniqueConstraint 设置联合唯一索引
    https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/jasonwang-2016/</span>p<span class="hljs-regexp">/5980237.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label252"></a></div><h2 id="简述tornado框架的特点">89. 简述Tornado框架的特点。</h2>
<pre><code class="hljs">
  Tornado的独特之处在于其所有开发工具能够使用在应用开发的任意阶段以及任何档次的硬件资源上。而且，完整集的Tornado工具可以使开发人员完全不用考虑与目标连接的策略或目标存储区大小。Tornado 结构的专门设计为开发人员和第三方工具厂商提供了一个开放环境。已有部分应用程序接口可以利用并附带参考书目，内容从开发环境接口到连接实现。Tornado包括强大的开发和调试工具，尤其适用于面对大量问题的嵌入式开发人员。这些工具包括C和C++源码级别的调试器，目标和工具管理，系统目标跟踪，内存使用分析和自动配置. 另外，所有工具能很方便地同时运行，很容易增加和交互式开发。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label253"></a></div><h2 id="简述tornado框架中future对象的作用">90. 简述Tornado框架中Future对象的作用？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//python.jobbole.com/87310/</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label254"></a></div><h2 id="tornado框架中如何编写websocket程序">91. Tornado框架中如何编写WebSocket程序？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/aguncn/p/5665916.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label255"></a></div><h2 id="tornado中静态文件是如何处理的">92. Tornado中静态文件是如何处理的？</h2>
<pre><code class="hljs lua">  如： &lt;link href=<span class="hljs-string">"{{static_url("</span>commons.css<span class="hljs-string">")}}"</span> rel=<span class="hljs-string">"stylesheet"</span> /&gt;
  处理方法:
  static_path = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">os</span>.paht.dirname(__file__), <span class="hljs-string">"static"</span>) #这里增加设置了静态路径
  另外一个修改就是在实例化 tornado.web.Application() 的时候，在参数中，出了有静态路径参数 static_path ，还有一个参数设置 <span class="hljs-built_in">debug</span>=True

  https://blog.csdn.net/hqzxsc2006/article/details/<span class="hljs-number">72833012</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label256"></a></div><h2 id="tornado操作mysql使用的模块">93. Tornado操作MySQL使用的模块？</h2>
<pre><code class="hljs css">
  <span class="hljs-selector-tag">torndb</span>是一个轻量级的基于<span class="hljs-selector-tag">MySQLdb</span>封装的一个模块，从<span class="hljs-selector-tag">tornado3</span><span class="hljs-selector-class">.0</span>版本以后，其已经作为一个独立模块发行了。<span class="hljs-selector-tag">torndb</span>依赖于<span class="hljs-selector-tag">MySQLdb</span>模块，因此，在使用<span class="hljs-selector-tag">torndb</span>模块时，要保证系统中已经有<span class="hljs-selector-tag">MySQLdb</span>模块。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label257"></a></div><h2 id="tornado操作redis使用的模块">94. Tornado操作redis使用的模块？</h2>
<pre><code class="hljs awk">  tornado-redis
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/guoqianqian5812/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">68587921</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label258"></a></div><h2 id="简述tornado框架的适用场景">95. 简述Tornado框架的适用场景？</h2>
<pre><code class="hljs ruby">  Tornado是使用Python编写的一个强大的、可扩展的Web服务器。它在处理严峻的网络流量时表现得足够强健，但却在创建和编写时有着足够的轻量级，并能够被用在大量的应用和工具中。

  我们现在所知道的Tornado是基于Bret Taylor和其他人员为FriendFeed所开发的网络服务框架，当FriendFeed被Facebook收购后得以开源。不同于那些最多只能达到<span class="hljs-number">10</span>,<span class="hljs-number">000</span>个并发连接的传统网络服务器，Tornado在设计之初就考虑到了性能因素，旨在解决C10K问题，这样的设计使得其成为一个拥有非常高性能的框架。此外，它还拥有处理安全性、用户验证、社交网络以及与外部服务（如数据库和网站API）进行异步交互的工具。
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/luotianshuai</span><span class="hljs-regexp">/p/</span><span class="hljs-number">5482612</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label259"></a></div><h2 id="git常见命令作用">96. git常见命令作用</h2>
<pre><code class="hljs dockerfile">  某个文件夹中的内容进行版本管理：
  进入文件夹，右键git bash
  git init 初始化，当前所在的文件夹可以被管理且以后版本相关的数据都会存储到.git文件中
  git status 查看当前文件夹以及子目录中文件是否发生变化：内容修改/新增文件/删除，已经变化的文件会变成红色，已经<span class="hljs-keyword">add</span><span class="bash">的文件会变成绿色
</span>  git <span class="hljs-keyword">add</span><span class="bash"> .  给发生变化的文件（贴上一个标签）或 将发生变化的文件放到某个地方，只写一个句点符就代表把git status中红色的文件全部打上标签
</span>  git commit -m <span class="hljs-string">'新增用户登录认证功能以及xxx功能'</span> 将“绿色”文件添加到版本中
  git log 查看所有版本提交记录，可以获取版本号
  git reset --hard 版本号   将最新的版本回退到更早的版本
  git reflog   回退到之前版本后悔了，再更新到最新或者最新之前的版本
  git reset --hard 版本 回退    </code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label260"></a></div><h2 id="简述以下git中stash命令作用以及相关其他命令">97. 简述以下git中stash命令作用以及相关其他命令。</h2>
<pre><code class="hljs perl">  stash用于将工作区发生变化的所有文件获取临时存储在“某个地方”，将工作区还原当前版本未操作前的状态；stash还可以将临时存储在“某个地方”的文件再次拿回到工作区。

  git stash             将当前工作区所有修改过的内容存储到“某个地方”，将工作区还原到当前版本未修改过的状态
  git stash list        查看“某个地方”存储的所有记录
  git stash clear     清空“某个地方”
  git stash <span class="hljs-keyword">pop</span>       将第一个记录从“某个地方”重新拿到工作区（可能有冲突）
  git stash apply     编号, 将指定编号记录从“某个地方”重新拿到工作区（可能有冲突） 
  git stash drop      编号，删除指定编号的记录</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label261"></a></div><h2 id="git-中-merge-和-rebase命令-的区别">98. git 中 merge 和 rebase命令 的区别。</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/xueweihan/p/5743327.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label262"></a></div><h2 id="公司如何基于git做的协同开发">99. 公司如何基于git做的协同开发？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/abelsu/p/5138136.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label263"></a></div><h2 id="如何基于git实现代码review">100. 如何基于git实现代码review？</h2>
<pre><code class="hljs awk">
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/maray/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">50206927</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label264"></a></div><h2 id="git如何实现v1.0-v2.0-等版本的管理">101. git如何实现v1.0 、v2.0 等版本的管理？</h2>
<pre><code class="hljs awk">
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zhazhaji/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">75258426</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label265"></a></div><h2 id="什么是gitlab">102. 什么是gitlab？</h2>
<pre><code class="hljs nginx">
  <span class="hljs-attribute">GitLab</span> 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。安装方法是参考GitLab在GitHub上的Wiki页面。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label266"></a></div><h2 id="github和gitlab的区别">103. github和gitlab的区别？</h2>
<pre><code class="hljs cmake">  先说一下相同点，二者都是基于web的Git仓库，在很大程度上GitLab是仿照GitHub来做的，它们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。

  GitHub作为开源代码库及版本控制系统，拥有超过<span class="hljs-number">900</span>万的开发者用户，目前仍然是最火的开源项目托管系统。GitHub同时提供公共仓库和私有仓库，但如果要使用私有仓库，是需要付费的。

  而GitLab解决了这个问题，你可以在上面创建私人的免费仓库。

  GitLab让开发团队对他们的代码仓库拥有更多的控制，相比于GitHub，它有不少的特色：

  允许免费设置仓库权限；允许用户选择分享一个<span class="hljs-keyword">project</span>的部分代码；允许用户设置<span class="hljs-keyword">project</span>的获取权限，进一步的提升安全性；可以设置获取到团队整体的改进进度；通过innersourcing让不在权限范围内的人访问不到该资源。

  从代码私有性方面来看，有时公司并不希望员工获取到全部的代码，这个时候GitLab无疑是更好的选择。但对于开源项目而言，GitHub依然是代码托管的首选。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label267"></a></div><h2 id="如何为github上的开源项目贡献代码">104. 如何为github上的开源项目贡献代码？</h2>
<pre><code class="hljs sql">  对一个开源项目有足够了解的情况下，如果你发现问题或者更好的解决方案的话，可以开个issue先。
  一般情况下维护这个项目的人或者其他使用这个项目的人会参与讨论的，然后基于这些讨论你可以发一些pull requests。
  如果你的方案得到很多人赞同的话，项目维护人员会把他们<span class="hljs-keyword">merge</span>，你也就成了这个项目的contributor了。
  当然很多情况下，你开的这个issue已经有人提过了，或者说是你自己误解了，但是相信在和其他开发人员交流的过程中，你也能学到许多。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label268"></a></div><h2 id="git中-.gitignore文件的作用">105. git中 .gitignore文件的作用?</h2>
<pre><code class="hljs css">  一般来说每个<span class="hljs-selector-tag">Git</span>项目中都需要一个“<span class="hljs-selector-class">.gitignore</span>”文件，这个文件的作用就是告诉<span class="hljs-selector-tag">Git</span>哪些文件不需要添加到版本管理中。

  实际项目中，很多文件都是不需要版本管理的，比如<span class="hljs-selector-tag">Python</span>的<span class="hljs-selector-class">.pyc</span>文件和一些包含密码的配置文件等等。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label269"></a></div><h2 id="什么是敏捷开发">106. 什么是敏捷开发？</h2>
<pre><code class="hljs">
  敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label270"></a></div><h2 id="简述-jenkins-工具的作用">107. 简述 jenkins 工具的作用?</h2>
<pre><code class="hljs">
  Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label271"></a></div><h2 id="公司如何实现代码发布">108. 公司如何实现代码发布？</h2>
<pre><code class="hljs dockerfile">  <span class="hljs-number">1</span>、开发人员提交代码更新，主要提交的字段包括“更新理由”，“svn代码路径”;
  <span class="hljs-number">2</span>、后端收到请求后，把此数据插入到数据库，标记此更新单为“等待预发布环境更新”的状态;
  <span class="hljs-number">3</span>、后台进程定时查询是否有等待预发布环境更新的更新单，如果有，读取svn路径，执行svn up更新代码操作,并标记此更新单为“预发布环境已更新，等待完成测试”;
  <span class="hljs-number">4</span>、开发人员或者测试人员通过预发布环境的域名来测试功能是否正常，如果不正常，作代码修改后提交svn，再到web发布后台点击“返回修改”，对svn路径或者不做任何修改再点击“重新提交”，然后更新单又一次回到”等待预发布环境更新“状态。循环<span class="hljs-number">3</span>、<span class="hljs-number">4</span>步骤，直至预发布环境测试通过为止;
  <span class="hljs-number">5</span>、在确认测试通过后，开发人员点击”测试通过“，这时更新单进入”等待审核状态“;
  <span class="hljs-number">6</span>、负责人确认可以发布后，点击”审批“按钮，这时更新单进入”审核通过，等待执行发布操作“的状态。这时,开发人员得到发布代码的授权;
  <span class="hljs-number">7</span>、开发人员点击”发布代码“按钮，更新单进入”已执行发布，等待系统完成发布“状态;
  <span class="hljs-number">8</span>、后台进程查询状态为”已执行发布，等待系统完成发布“的更新单，执行git发布命令。git命令大概为，进入预发布代码目录，执行git <span class="hljs-keyword">add</span><span class="bash"> .;git commit -m “更新原因”;git tag 上一次版本号+1，再进入已发布代码的目录,执行git pull同步预发布代码目录的更改。最后调用rsync命令同步代码到生产环境。
</span>
  http://blog.jobbole.com/<span class="hljs-number">110304</span>/</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label272"></a></div><h2 id="简述-rabbitmqkafkazeromq的区别">109. 简述 RabbitMQ、Kafka、ZeroMQ的区别？</h2>
<pre><code class="hljs vbnet">  RabbitMQ
  RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。

  Redis
  Redis是一个基于<span class="hljs-keyword">Key</span>-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个<span class="hljs-keyword">Key</span>-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行<span class="hljs-number">100</span>万次，每<span class="hljs-number">10</span>万次记录一次执行时间。测试数据分为<span class="hljs-number">128</span>Bytes、<span class="hljs-number">512</span>Bytes、<span class="hljs-number">1</span>K和<span class="hljs-number">10</span>K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了<span class="hljs-number">10</span>K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。

  ZeroMQ
  ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm <span class="hljs-number">0.9</span><span class="hljs-number">.0</span>以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从<span class="hljs-number">0.9</span>版本开始同时支持ZeroMQ和Netty作为传输模块）。

  ActiveMQ
  ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。

  Kafka/Jafka
  Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(<span class="hljs-number">1</span>)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到<span class="hljs-number">10</span>W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label273"></a></div><h2 id="rabbitmq如何在消费者获取任务后未处理完前就挂掉时保证数据不丢失">110. RabbitMQ如何在消费者获取任务后未处理完前就挂掉时，保证数据不丢失？</h2>
<pre><code class="hljs">
  略</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label274"></a></div><h2 id="rabbitmq如何对消息做持久化">111. RabbitMQ如何对消息做持久化？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/xiangjun555/articles/7874006.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label275"></a></div><h2 id="rabbitmq如何控制消息被消费的顺序">112. RabbitMQ如何控制消息被消费的顺序？</h2>
<pre><code class="hljs awk">
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/varyall/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">79111745</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label276"></a></div><h2 id="以下rabbitmq的exchange-type分别代表什么意思如fanoutdirecttopic">113. 以下RabbitMQ的exchange type分别代表什么意思？如：fanout、direct、topic。</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.cnblogs.com/shenyixin/p/9084249.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label277"></a></div><h2 id="简述-celery-是什么以及应用场景">114. 简述 celery 是什么以及应用场景？</h2>
<pre><code class="hljs ruby">  Celery是由Python开发的一个简单、灵活、可靠的处理大量任务的分发系统，它不仅支持实时处理也支持任务调度。
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/wupeiqi</span><span class="hljs-regexp">/articles/</span><span class="hljs-number">8796552</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label278"></a></div><h2 id="简述celery运行机制">115. 简述celery运行机制。</h2>
<pre><code class="hljs">
  略</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label279"></a></div><h2 id="celery如何实现定时任务">116. celery如何实现定时任务？</h2>
<pre><code class="hljs">
  略</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label280"></a></div><h2 id="简述-celery多任务结构目录">117. 简述 celery多任务结构目录？</h2>
<pre><code class="hljs">
  略</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label281"></a></div><h2 id="celery中装饰器-app.task-和-shared_task的区别">118. celery中装饰器 @app.task 和 @shared_task的区别？</h2>
<pre><code class="hljs">
  略</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label282"></a></div><h2 id="简述-requests模块的作用及基本使用">119. 简述 requests模块的作用及基本使用？</h2>
<pre><code class="hljs less">  模拟浏览器发送请求
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/linhaifeng/articles/7785043.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label283"></a></div><h2 id="简述-beautifulsoup模块的作用及基本使用">120. 简述 beautifulsoup模块的作用及基本使用？</h2>
<pre><code class="hljs ruby">  Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/linhaifeng</span><span class="hljs-regexp">/articles/</span><span class="hljs-number">7783586</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label284"></a></div><h2 id="简述-seleninu模块的作用及基本使用">121. 简述 seleninu模块的作用及基本使用?</h2>
<pre><code class="hljs ruby">  selenium最初是一个自动化测试工具,而爬虫中使用它主要是为了解决requests无法直接执行JavaScript代码的问题

  selenium本质是通过驱动浏览器，完全模拟浏览器的操作，比如跳转、输入、点击、下拉等，来拿到网页渲染之后的结果，可支持多种浏览器
  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/linhaifeng</span><span class="hljs-regexp">/articles/</span><span class="hljs-number">7783599</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label285"></a></div><h2 id="scrapy框架中各组件的工作流程">122. scrapy框架中各组件的工作流程？</h2>
<pre><code class="hljs awk">  <span class="hljs-comment">#1、生成初始的Requests来爬取第一个URLS，并且标识一个回调函数</span>
  第一个请求定义在start_requests()方法内默认从start_urls列表中获得url地址来生成Request请求，默认的回调函数是parse方法。回调函数在下载完成返回response时自动触发

  <span class="hljs-comment">#2、在回调函数中，解析response并且返回值</span>
  返回值可以<span class="hljs-number">4</span>种：
          包含解析数据的字典
          Item对象
          新的Request对象（新的Requests也需要指定一个回调函数）
          或者是可迭代对象（包含Items或Request）

  <span class="hljs-comment">#3、在回调函数中解析页面内容</span>
  通常使用Scrapy自带的Selectors，但很明显你也可以使用Beutifulsoup，lxml或其他你爱用啥用啥。

  <span class="hljs-comment">#4、最后，针对返回的Items对象将会被持久化到数据库</span>
  通过Item Pipeline组件存到数据库：https:<span class="hljs-regexp">//</span>docs.scrapy.org<span class="hljs-regexp">/en/</span>latest<span class="hljs-regexp">/topics/i</span>tem-pipeline.html<span class="hljs-comment">#topics-item-pipeline）</span>
  或者导出到不同的文件（通过Feed exports：https:<span class="hljs-regexp">//</span>docs.scrapy.org<span class="hljs-regexp">/en/</span>latest<span class="hljs-regexp">/topics/</span>feed-exports.html<span class="hljs-comment">#topics-feed-exports）</span>
  http:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/linhaifeng/</span>articles<span class="hljs-regexp">/7811861.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label286"></a></div><h2 id="scrapy框架中如何设置代理两种方法">123. scrapy框架中如何设置代理（两种方法）？</h2>
<pre><code class="hljs javascript">  scrapy自带的代理组件：
  <span class="hljs-keyword">from</span> scrapy.downloadermiddlewares.httpproxy <span class="hljs-keyword">import</span> HttpProxyMiddleware
  <span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> getproxies</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label287"></a></div><h2 id="scrapy框架中如何实现大文件的下载">124. scrapy框架中如何实现大文件的下载？</h2>
<pre><code class="hljs ruby">  持久化时:
  from twisted.web.client import Agent, getPage, ResponseDone, PotentialDataLoss

  from twisted.internet import defer, reactor, protocol
  from twisted.web._newclient import Response
  from io import BytesIO


  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_ResponseReader</span>(<span class="hljs-title">protocol</span>.<span class="hljs-title">Protocol</span>):</span>

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, finished, txresponse, file_name)</span></span>:
          <span class="hljs-keyword">self</span>._finished = finished
          <span class="hljs-keyword">self</span>._txresponse = txresponse
          <span class="hljs-keyword">self</span>._bytes_received = <span class="hljs-number">0</span>
          <span class="hljs-keyword">self</span>.f = open(file_name, mode=<span class="hljs-string">'wb'</span>)

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dataReceived</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, bodyBytes)</span></span>:
          <span class="hljs-keyword">self</span>._bytes_received += len(bodyBytes)

          <span class="hljs-comment"># 一点一点的下载</span>
          <span class="hljs-keyword">self</span>.f.write(bodyBytes)

          <span class="hljs-keyword">self</span>.f.flush()

      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connectionLost</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, reason)</span></span>:
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>._finished.<span class="hljs-symbol">called:</span>
              <span class="hljs-keyword">return</span>
          <span class="hljs-keyword">if</span> reason.check(ResponseDone):
              <span class="hljs-comment"># 下载完成</span>
              <span class="hljs-keyword">self</span>._finished.callback((<span class="hljs-keyword">self</span>._txresponse, <span class="hljs-string">'success'</span>))
          elif reason.check(PotentialDataLoss):
              <span class="hljs-comment"># 下载部分</span>
              <span class="hljs-keyword">self</span>._finished.callback((<span class="hljs-keyword">self</span>._txresponse, <span class="hljs-string">'partial'</span>))
          <span class="hljs-symbol">else:</span>
              <span class="hljs-comment"># 下载异常</span>
              <span class="hljs-keyword">self</span>._finished.errback(reason)

          <span class="hljs-keyword">self</span>.f.close()</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label288"></a></div><h2 id="scrapy中如何实现限速">125. scrapy中如何实现限速？</h2>
<pre><code class="hljs awk">
  http:<span class="hljs-regexp">//</span>scrapy-chs.readthedocs.io<span class="hljs-regexp">/zh_CN/</span><span class="hljs-number">1.0</span><span class="hljs-regexp">/topics/</span>autothrottle.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label289"></a></div><h2 id="scrapy中如何实现暂定爬虫">126. scrapy中如何实现暂定爬虫？</h2>
<pre><code class="hljs less">  有些情况下，例如爬取大的站点，我们希望能暂停爬取，之后再恢复运行。

  <span class="hljs-selector-tag">Scrapy</span>通过如下工具支持这个功能:

  一个把调度请求保存在磁盘的调度器
  一个把访问请求保存在磁盘的副本过滤器<span class="hljs-selector-attr">[duplicates filter]</span>
  一个能持续保持爬虫状态(键/值对)的扩展
  <span class="hljs-selector-tag">Job</span> 路径
  要启用持久化支持，你只需要通过 <span class="hljs-selector-tag">JOBDIR</span> 设置 <span class="hljs-selector-tag">job</span> <span class="hljs-selector-tag">directory</span> 选项。这个路径将会存储 所有的请求数据来保持一个单独任务的状态(例如：一次spider爬取(a spider run))。必须要注意的是，这个目录不允许被不同的<span class="hljs-selector-tag">spider</span> 共享，甚至是同一个<span class="hljs-selector-tag">spider</span>的不同<span class="hljs-selector-tag">jobs</span>/<span class="hljs-selector-tag">runs</span>也不行。也就是说，这个目录就是存储一个 单独 <span class="hljs-selector-tag">job</span>的状态信息。
  <span class="hljs-selector-tag">https</span>:<span class="hljs-comment">//scrapy-chs.readthedocs.io/zh_CN/1.0/topics/jobs.html?highlight=item</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label290"></a></div><h2 id="scrapy中如何进行自定制命令">127. scrapy中如何进行自定制命令？</h2>
<pre><code class="hljs ruby">  在spiders同级创建任意目录，如：commands
  在其中创建 crawlall.py 文件 （此处文件名就是自定义的命令）
  from scrapy.commands import ScrapyCommand
      from scrapy.utils.project import get_project_settings


      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span>(<span class="hljs-title">ScrapyCommand</span>):</span>

          requires_project = True

          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">syntax</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
              <span class="hljs-keyword">return</span> <span class="hljs-string">'[options]'</span>

          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">short_desc</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
              <span class="hljs-keyword">return</span> <span class="hljs-string">'Runs all of the spiders'</span>

          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, args, opts)</span></span>:
              spider_list = <span class="hljs-keyword">self</span>.crawler_process.spiders.list()
              <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-symbol">spider_list:</span>
                  <span class="hljs-keyword">self</span>.crawler_process.crawl(name, **opts.__dict_<span class="hljs-number">_</span>)
              <span class="hljs-keyword">self</span>.crawler_process.start()
  在settings.py 中添加配置 COMMANDS_MODULE = <span class="hljs-string">'项目名称.目录名称'</span>
  在项目目录执行命令：scrapy crawlall 

  <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/www.cnblogs.com/wupeiqi</span><span class="hljs-regexp">/articles/</span><span class="hljs-number">6229292</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label291"></a></div><h2 id="scrapy中如何实现的记录爬虫的深度">128. scrapy中如何实现的记录爬虫的深度？</h2>
<pre><code class="hljs css">  <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">scrapy</span><span class="hljs-selector-class">.contrib</span><span class="hljs-selector-class">.spidermiddleware</span><span class="hljs-selector-class">.depth</span><span class="hljs-selector-class">.DepthMiddleware</span>
  <span class="hljs-selector-tag">DepthMiddleware</span>是一个用于追踪每个<span class="hljs-selector-tag">Request</span>在被爬取的网站的深度的中间件。 其可以用来限制爬取深度的最大深度或类似的事情。

  <span class="hljs-selector-tag">DepthMiddleware</span> 可以通过下列设置进行配置(更多内容请参考设置文档):

  <span class="hljs-selector-tag">DEPTH_LIMIT</span> <span class="hljs-selector-tag">-</span> 爬取所允许的最大深度，如果为0，则没有限制。
  <span class="hljs-selector-tag">DEPTH_STATS</span> <span class="hljs-selector-tag">-</span> 是否收集爬取状态。
  <span class="hljs-selector-tag">DEPTH_PRIORITY</span> <span class="hljs-selector-tag">-</span> 是否根据其深度对<span class="hljs-selector-tag">requet</span>安排优先级</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label292"></a></div><h2 id="scrapy中的pipelines工作原理">129. scrapy中的pipelines工作原理？</h2>
<pre><code class="hljs awk">  Scrapy 提供了 pipeline 模块来执行保存数据的操作。在创建的 Scrapy 项目中自动创建了一个 pipeline.py 文件，同时创建了一个默认的 Pipeline 类。我们可以根据需要自定义 Pipeline 类，然后在 settings.py 文件中进行配置即可
  https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/Ahri_J/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">72472170</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label293"></a></div><h2 id="scrapy的pipelines如何丢弃一个item对象">130. scrapy的pipelines如何丢弃一个item对象？</h2>
<pre><code class="hljs">
  略</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label294"></a></div><h2 id="scrapy中爬虫中间件和下载中间件的作用">131. scrapy中爬虫中间件和下载中间件的作用？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/wupeiqi/articles/6229292.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label295"></a></div><h2 id="scrapy-redis组件的作用">132. scrapy-redis组件的作用？</h2>
<pre><code class="hljs nginx">  <span class="hljs-attribute">scheduler</span> - 调度器
  dupefilter - URL去重规则（被调度器使用）
  pipeline   - 数据持久化</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label296"></a></div><h2 id="scrapy-redis组件中如何实现的任务的去重">133. scrapy-redis组件中如何实现的任务的去重？</h2>
<pre><code class="hljs python">  定义去重规则（被调度器调用并应用）
   
      a. 内部会使用以下配置进行连接Redis
   
          <span class="hljs-comment"># REDIS_HOST = 'localhost'                            # 主机名</span>
          <span class="hljs-comment"># REDIS_PORT = 6379                                   # 端口</span>
          <span class="hljs-comment"># REDIS_URL = 'redis://user:pass@hostname:9001'       # 连接URL（优先于以上配置）</span>
          <span class="hljs-comment"># REDIS_PARAMS  = {}                                  # Redis连接参数             默认：REDIS_PARAMS = {'socket_timeout': 30,'socket_connect_timeout': 30,'retry_on_timeout': True,'encoding': REDIS_ENCODING,}）</span>
          <span class="hljs-comment"># REDIS_PARAMS['redis_cls'] = 'myproject.RedisClient' # 指定连接Redis的Python模块  默认：redis.StrictRedis</span>
          <span class="hljs-comment"># REDIS_ENCODING = "utf-8"                            # redis编码类型             默认：'utf-8'</span>
       
      b. 去重规则通过redis的集合完成，集合的Key为：
       
          key = defaults.DUPEFILTER_KEY % {<span class="hljs-string">'timestamp'</span>: int(time.time())}
          默认配置：
              DUPEFILTER_KEY = <span class="hljs-string">'dupefilter:%(timestamp)s'</span>
                
      c. 去重规则中将url转换成唯一标示，然后在redis中检查是否已经在集合中存在
       
          <span class="hljs-keyword">from</span> scrapy.utils <span class="hljs-keyword">import</span> request
          <span class="hljs-keyword">from</span> scrapy.http <span class="hljs-keyword">import</span> Request
           
          req = Request(url=<span class="hljs-string">'http://www.cnblogs.com/wupeiqi.html'</span>)
          result = request.request_fingerprint(req)
          print(result) <span class="hljs-comment"># 8ea4fd67887449313ccc12e5b6b92510cc53675c</span>
           
           
          PS:
              - URL参数位置不同时，计算结果一致；
              - 默认请求头不在计算范围，include_headers可以设置指定请求头
              示例：
                  <span class="hljs-keyword">from</span> scrapy.utils <span class="hljs-keyword">import</span> request
                  <span class="hljs-keyword">from</span> scrapy.http <span class="hljs-keyword">import</span> Request
                   
                  req = Request(url=<span class="hljs-string">'http://www.baidu.com?name=8&amp;id=1'</span>,callback=<span class="hljs-keyword">lambda</span> x:print(x),cookies={<span class="hljs-string">'k1'</span>:<span class="hljs-string">'vvvvv'</span>})
                  result = request.request_fingerprint(req,include_headers=[<span class="hljs-string">'cookies'</span>,])
                   
                  print(result)
                   
                  req = Request(url=<span class="hljs-string">'http://www.baidu.com?id=1&amp;name=8'</span>,callback=<span class="hljs-keyword">lambda</span> x:print(x),cookies={<span class="hljs-string">'k1'</span>:<span class="hljs-number">666</span>})
                   
                  result = request.request_fingerprint(req,include_headers=[<span class="hljs-string">'cookies'</span>,])
                   
                  print(result)
           
  <span class="hljs-string">"""
  # Ensure all spiders share same duplicates filter through redis.
  # DUPEFILTER_CLASS = "scrapy_redis.dupefilter.RFPDupeFilter"</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label297"></a></div><h2 id="scrapy-redis的调度器如何实现任务的深度优先和广度优先">134. scrapy-redis的调度器如何实现任务的深度优先和广度优先？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.cnblogs.com/wupeiqi/articles/6912807.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label298"></a></div><h2 id="简述-vitualenv-及应用场景">135. 简述 vitualenv 及应用场景?</h2>
<pre><code class="hljs ruby">  virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/technologylife</span><span class="hljs-regexp">/p/</span><span class="hljs-number">6635631</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label299"></a></div><h2 id="简述-pipreqs-及应用场景">136. 简述 pipreqs 及应用场景？</h2>
<pre><code class="hljs ruby">  查找python项目依赖并生成requirements.txt
  <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/www.cnblogs.com/bonelee</span><span class="hljs-regexp">/p/</span><span class="hljs-number">8183038</span>.html</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label300"></a></div><h2 id="在python中使用过什么代码检查工具">137. 在Python中使用过什么代码检查工具？</h2>
<pre><code class="hljs">  1）PyFlakes：静态检查Python代码逻辑错误的工具。
  2）Pep8： 静态检查PEP8编码风格的工具。
  3）NedBatchelder’s McCabe script：静态分析Python代码复杂度的工具。
  Python代码分析工具：PyChecker、Pylint</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label301"></a></div><h2 id="简述-saltstackansiblefabricpuppet工具的作用">138. 简述 saltstack、ansible、fabric、puppet工具的作用？</h2>
<pre><code class="hljs">
  略</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label302"></a></div><h2 id="b-tree和b-tree的区别">139. B Tree和B+ Tree的区别？</h2>
<pre><code class="hljs less">
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.jianshu.com/p/0371c9569736</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label303"></a></div><h2 id="请列举常见排序并通过代码实现任意三种">140. 请列举常见排序并通过代码实现任意三种。</h2>
<pre><code class="hljs groovy">  冒泡<span class="hljs-regexp">/选择/</span>插入/快排
<span class="hljs-symbol">  https:</span><span class="hljs-comment">//www.cnblogs.com/Liqiongyu/p/5911613.html</span>
<span class="hljs-symbol">  http:</span><span class="hljs-comment">//www.cnblogs.com/feixuelove1009/p/6143539.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label304"></a></div><h2 id="请列举常见查找并通过代码实现任意三种">141. 请列举常见查找并通过代码实现任意三种。</h2>
<pre><code class="hljs awk">  无序查找<span class="hljs-regexp">/二分查找/</span>插值查找
  http:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/feixuelove1009/</span>p<span class="hljs-regexp">/6148357.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label305"></a></div><h2 id="请列举你熟悉的设计模式">142. 请列举你熟悉的设计模式？</h2>
<pre><code class="hljs javascript">  工厂模式/单例模式等
  https:<span class="hljs-comment">//www.cnblogs.com/Liqiongyu/p/5916710.html</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label306"></a></div><h2 id="有没有刷过leetcode">143. 有没有刷过leetcode？</h2>
<pre><code class="hljs less">  刷过刷过刷过
  <span class="hljs-attribute">https</span>:<span class="hljs-comment">//leetcode-cn.com/problemset/all/</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label307"></a></div><h2 id="列举熟悉的的linux命令">144. 列举熟悉的的Linux命令。</h2>
<pre><code class="hljs sql">  1.  mkdir –p  创建多级目录
  2.  ls  -l 显示详细信息
  3.  cd  <span class="hljs-keyword">change</span> <span class="hljs-keyword">directory</span> 进入到目录中
  <span class="hljs-number">4.</span>  pwd print working <span class="hljs-keyword">directory</span> 显示当前所在位置
  <span class="hljs-number">5.</span>  touch  创建文件   修改文件的时间戳
  <span class="hljs-number">6.</span>  vi   编辑文件
  <span class="hljs-number">7.</span>  cat  显示文件内容
  <span class="hljs-number">8.</span>  cp  copy 复制
  <span class="hljs-number">9.</span>  mv  <span class="hljs-keyword">move</span> 移动
  <span class="hljs-number">10.</span> rm  删除文件或目录 -f  强制删除不提示 -r  递归删除目录 慎用
  <span class="hljs-number">11.</span> find 查找 -<span class="hljs-keyword">type</span>  f(<span class="hljs-keyword">file</span>)  d(dir)   -<span class="hljs-keyword">name</span>  名字
  <span class="hljs-number">12.</span> grep  过滤  -v  排除
  <span class="hljs-number">13.</span> <span class="hljs-keyword">head</span>  显示文件的前几行  默认显示文件的前<span class="hljs-number">10</span>行 -n2   === <span class="hljs-number">-2</span>  显示文件的前<span class="hljs-number">2</span>行
  <span class="hljs-number">14.</span> tail  显示文件的最后几行  默认显示文件的后<span class="hljs-number">10</span>行   
    -n1   === <span class="hljs-number">-1</span>  显示文件的最后<span class="hljs-number">1</span>行
    -f    实时显示文件的更新
  <span class="hljs-number">15.</span> sed   取行  
      -n    取消默认输出 
    -i    修改文件的内容
  <span class="hljs-number">16.</span> tar   创建解压查看压缩包
  <span class="hljs-number">17.</span> yum <span class="hljs-keyword">install</span>  yum <span class="hljs-keyword">install</span> -y
  <span class="hljs-number">18.</span> ping  baidu.com</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label308"></a></div><h2 id="公司线上服务器是什么系统">145. 公司线上服务器是什么系统？</h2>
<pre><code class="hljs">
  Linux/Centos</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label309"></a></div><h2 id="解释-pvuv-的含义">146. 解释 PV、UV 的含义？</h2>
<pre><code class="hljs">  PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。
  IP访问数指独立IP访问数，计算是以一个独立的IP在一个计算时段内访问网站计算为1次IP访问数。在同一个计算时段内不管这个IP访问多少次均计算为1次。计算时段有以1天为一个计算时段，也有以1个小时为一个计算时段。
  UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。
  在同一个局域网中对互联网访问时对外通常是同一个IP，如果该局域网中有10台终端在同一个计算时段内访问同一个网站，对该网站的独立IP访问数贡献为1，而不是10。而此时UV访问数则为10。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label310"></a></div><h2 id="解释-qps的含义">147. 解释 QPS的含义？</h2>
<pre><code class="hljs nginx">  <span class="hljs-attribute">Query</span> Per Second
  每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label311"></a></div><h2 id="uwsgi和wsgi的区别">148. uwsgi和wsgi的区别？</h2>
<pre><code class="hljs delphi">  WSGI：全称是Web Server Gateway <span class="hljs-keyword">Interface</span>，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP <span class="hljs-number">3333</span>中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。
  uwsgi：与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(<span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> information)，每一个uwsgi packet前<span class="hljs-number">4</span>byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的<span class="hljs-number">10</span>倍快。
  uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。
  https:<span class="hljs-comment">//www.jianshu.com/p/679dee0a4193</span></code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label312"></a></div><h2 id="supervisor的作用">149. supervisor的作用？</h2>
<pre><code class="hljs perl">
  supervisor管理进程，是通过<span class="hljs-keyword">fork</span>/<span class="hljs-keyword">exec</span>的方式将这些被管理的进程当作supervisor的子进程来启动，所以我们只需要将要管理进程的可执行文件的路径添加到supervisor的配置文件中就好了。此时被管理进程被视为supervisor的子进程，若该子进程异常终端，则父进程可以准确的获取子进程异常终端的信息，通过在配置文件中设置autostart=ture，可以实现对异常中断的子进程的自动重启。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label313"></a></div><h2 id="什么是反向代理">150. 什么是反向代理？</h2>
<pre><code class="hljs javascript">
  反向代理（Reverse <span class="hljs-built_in">Proxy</span>）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label314"></a></div><h2 id="简述ssh的整个过程">151. 简述SSH的整个过程。</h2>
<pre><code class="hljs dockerfile">  SSH 为 Secure <span class="hljs-keyword">Shell</span><span class="bash"> 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。
</span>  https://www.jianshu.com/p/<span class="hljs-number">33461</span>b619d53</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label315"></a></div><h2 id="有问题都去哪找解决方案">152. 有问题都去哪找解决方案？</h2>
<pre><code class="hljs">
  风中</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label316"></a></div><h2 id="是否有关注什么技术类的公众号">153. 是否有关注什么技术类的公众号？</h2>
<pre><code class="hljs groovy">
  蓝翔技校<span class="hljs-regexp">/摩托车维修/</span>脱单教程</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label317"></a></div><h2 id="最近在研究什么新技术">154. 最近在研究什么新技术？</h2>
<pre><code class="hljs">
  NP完全问题、霍奇猜想、庞加莱猜想、黎曼假设、杨-米尔斯存在性和质量缺口、纳卫尔-斯托可方程、BSD猜想</code></pre>
<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33"></a><a name="_label318"></a></div><h2 id="是否了解过领域驱动模型">155. 是否了解过领域驱动模型？</h2>
<pre><code class="hljs awk">  Domain-Driven Design
  https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/netfocus/</span>archive<span class="hljs-regexp">/2011/</span><span class="hljs-number">10</span><span class="hljs-regexp">/10/</span><span class="hljs-number">2204949</span>.html</code></pre>
</div><div id="MySignature"></div>



</body></html>